WEBVTT
Kind: captions
Language: en

00:00:13.840 --> 00:00:20.080
So, in the previous session we have learned how&nbsp;
to list the packages. So, we have used a command&nbsp;&nbsp;

00:00:20.080 --> 00:00:28.560
called dpkg query, which allowed us to combine&nbsp;
the various fields to output them onto the screen&nbsp;&nbsp;

00:00:28.560 --> 00:00:33.440
and we have seen a list of packages that&nbsp;
is coming onto the screen. And we have&nbsp;&nbsp;

00:00:33.440 --> 00:00:40.240
used the grep to pick up and we can actually now&nbsp;
modify that to a little bit further extent.
&nbsp;

00:00:40.960 --> 00:00:48.640
So, I am just going to run the same query, so&nbsp;
minus W to provide information about the packages&nbsp;&nbsp;

00:00:48.640 --> 00:00:56.320
and minus f to provide the pattern. So, I have&nbsp;
the section I would like to have and then one&nbsp;&nbsp;

00:00:56.320 --> 00:01:03.840
space and then the name of the package has to&nbsp;
be shown, and after that I would like to have&nbsp;&nbsp;

00:01:03.840 --> 00:01:11.200
the newline character and then now you see that&nbsp;
this list is quite long. And here is where we&nbsp;&nbsp;

00:01:11.200 --> 00:01:17.120
would like to use the grep features.
So, let us say I use the extended&nbsp;&nbsp;

00:01:17.120 --> 00:01:25.200
regular expression engine, and I would like&nbsp;
to look at all those package names which have&nbsp;&nbsp;

00:01:25.200 --> 00:01:33.680
exactly four characters. So, W get is a package&nbsp;
name with four characters, n map is a package name&nbsp;&nbsp;

00:01:33.680 --> 00:01:41.440
with four characters. So, I want to pick up those&nbsp;
kinds of package names. So, how do I provide the&nbsp;&nbsp;

00:01:41.440 --> 00:01:46.720
pattern? So, I would actually have space because&nbsp;
the package name is coming after the space.
&nbsp;

00:01:46.720 --> 00:01:51.200
So, I do not want to match those which are&nbsp;
in the section, only in the package I would&nbsp;&nbsp;

00:01:51.200 --> 00:01:56.160
like to match. And then I do not know what&nbsp;
character has to be matched, so I put a dot.&nbsp;&nbsp;

00:01:56.800 --> 00:02:03.840
So, any character can be there, but that&nbsp;
should occur exactly four times. And after&nbsp;&nbsp;

00:02:03.840 --> 00:02:09.440
the package name has been given, I should go to&nbsp;
the end of the line. So, the dollar will tell me&nbsp;&nbsp;

00:02:09.440 --> 00:02:13.760
that it is going to be end of the line.
So, now look at that and you see that we&nbsp;&nbsp;

00:02:13.760 --> 00:02:20.480
are getting package names which are exactly four&nbsp;
characters long. And what happens if I do not have&nbsp;&nbsp;

00:02:20.480 --> 00:02:26.880
the dollar there. You see that it would match&nbsp;
four characters, but the remaining characters&nbsp;&nbsp;

00:02:26.880 --> 00:02:33.360
are also present which are not being looked at.&nbsp;
So, by putting the dollar here we are insisting&nbsp;&nbsp;

00:02:33.360 --> 00:02:37.280
that the package name should have been&nbsp;
finished in just four characters.
&nbsp;

00:02:38.640 --> 00:02:43.280
And what is the blank here for, so I would&nbsp;
actually also show you what happens if you&nbsp;&nbsp;

00:02:43.280 --> 00:02:49.120
do not have the blank here. You would see that&nbsp;
the matching is occurring also in the name of the&nbsp;&nbsp;

00:02:49.120 --> 00:02:55.760
section so that I do not want. So, I put a blank&nbsp;
here so that it is matching from the second field&nbsp;&nbsp;

00:02:55.760 --> 00:03:02.080
onwards and then it is matching only in the name&nbsp;
of the package and the dollar is actually matching&nbsp;&nbsp;

00:03:02.080 --> 00:03:08.160
only the end of the line to be occurring after&nbsp;
four characters of the name of the package.
&nbsp;

00:03:08.160 --> 00:03:12.240
Now, let us say I would like to have the&nbsp;
name of the package to be starting with g&nbsp;&nbsp;

00:03:12.960 --> 00:03:17.360
and the three characters after that, so g&nbsp;
something, something, something. Now, you see&nbsp;&nbsp;

00:03:17.360 --> 00:03:23.840
that this is giving us the package names which&nbsp;
starts with the g and are four later words, gmp&nbsp;&nbsp;

00:03:24.800 --> 00:03:34.240
or grep or gzip or gftp etc. And we could&nbsp;
also look at, after g I can have either 1&nbsp;&nbsp;

00:03:34.880 --> 00:03:41.200
or up to let us say 5 characters. 
And you see that slightly a longer list of g&nbsp;&nbsp;

00:03:42.960 --> 00:03:48.880
starting packages are there, g plus plus onwards&nbsp;
all the way up to guake terminal which we have&nbsp;&nbsp;

00:03:48.880 --> 00:03:54.320
looked at in one of the earlier classes. So,&nbsp;
you could see that the egrep can be used in a&nbsp;&nbsp;

00:03:54.320 --> 00:04:01.120
very powerful manner to process the matching of&nbsp;
the string precisely telling what character you&nbsp;&nbsp;

00:04:01.120 --> 00:04:06.560
would like to match and how many times etc. 
Now, let us say you would like to have all those&nbsp;&nbsp;

00:04:06.560 --> 00:04:10.080
packages which are coming under&nbsp;
the category called mathematics.&nbsp;&nbsp;

00:04:10.080 --> 00:04:15.040
So, that you want to go through those packages&nbsp;
and be thorough of it. So, let us look at that.&nbsp;&nbsp;

00:04:17.600 --> 00:04:24.640
Math should be matched within the name of the&nbsp;
package. Now, you see that it is matching also&nbsp;&nbsp;

00:04:24.640 --> 00:04:30.000
names of packages here, but not only sections.&nbsp;
Now, I want to match it only for the section.&nbsp;&nbsp;

00:04:30.000 --> 00:04:34.240
So which means that I want the math character&nbsp;
set to should be only in the beginning of the&nbsp;&nbsp;

00:04:34.240 --> 00:04:38.000
line. So already we know the anchor for&nbsp;
that. So I put the hat in the front.
&nbsp;

00:04:38.720 --> 00:04:43.280
And now you see that only those packages&nbsp;
which come under the section called math&nbsp;&nbsp;

00:04:43.280 --> 00:04:48.080
are being displayed, but not the names&nbsp;
of packages which have math in middle&nbsp;&nbsp;

00:04:48.080 --> 00:04:55.840
but actually belonging to some other section. So,&nbsp;
you see the utility of the egrep along with the&nbsp;&nbsp;

00:04:57.040 --> 00:05:02.240
features such as the hat as well as the number&nbsp;
of times the particular character should come&nbsp;&nbsp;

00:05:02.240 --> 00:05:09.840
so that you can actually precisely pick up the&nbsp;
lines of output that you are interested in.
&nbsp;

00:05:10.720 --> 00:05:17.040
Now, there are some packages which are coming&nbsp;
from the kde graphical user interface of&nbsp;&nbsp;

00:05:17.600 --> 00:05:26.400
Ubuntu and the default GUI for Ubuntu is&nbsp;
gnome. So, you can look at those also here. So,&nbsp;&nbsp;

00:05:28.160 --> 00:05:34.240
k and after that I have something that&nbsp;
starts with k and then a dollar. So,&nbsp;&nbsp;

00:05:34.240 --> 00:05:41.360
packages that starts with k. And there are many&nbsp;
of them. So, I think that k is not sufficient,&nbsp;&nbsp;

00:05:44.080 --> 00:05:49.600
kd. So, now this is much better,&nbsp;
kde is common desktop environment&nbsp;&nbsp;

00:05:49.600 --> 00:05:55.040
and there are some packages that are coming. 
So, kdenlive is like an editor used to trim the&nbsp;&nbsp;

00:05:55.040 --> 00:06:00.640
videos etc., which is what I do for our course.&nbsp;
And there are also other tools. So, these are&nbsp;&nbsp;

00:06:00.640 --> 00:06:05.680
coming from a common desktop environment, which&nbsp;
requires some other libraries also to be present&nbsp;&nbsp;

00:06:05.680 --> 00:06:11.920
compared to the gnome user interface. So, you&nbsp;
think about what way you want to pick up and&nbsp;&nbsp;

00:06:11.920 --> 00:06:17.520
analyze the pattern that would capture them&nbsp;
accurately. And if you have used the thermal&nbsp;&nbsp;

00:06:17.520 --> 00:06:23.360
colors enabled then you can also find out what&nbsp;
has been matched and that would also help you&nbsp;&nbsp;

00:06:23.360 --> 00:06:27.840
understand the pattern matching better. 
Now, there are some features that are available&nbsp;&nbsp;

00:06:27.840 --> 00:06:32.320
in the grep which help you with respect to the&nbsp;
type of character sets that can be matched,&nbsp;&nbsp;

00:06:32.320 --> 00:06:38.080
so alphabetic, alphanumeric, digits etc. So,&nbsp;
we will look at them using a file in which I&nbsp;&nbsp;

00:06:38.080 --> 00:06:44.880
have put intentionally some punctuation marks or&nbsp;
control characters. How do we insert non-typable&nbsp;&nbsp;

00:06:44.880 --> 00:06:50.000
characters in a text file is something that&nbsp;
we will learn when we come to the text editors&nbsp;&nbsp;

00:06:50.000 --> 00:06:55.440
shortly, but for now I will just display the text&nbsp;
file to you and then we will see how we can pick&nbsp;&nbsp;

00:06:55.440 --> 00:07:00.400
specific lines from it depending upon the type&nbsp;
of character set that we would like to match.
&nbsp;

00:07:00.400 --> 00:07:07.120
So, here is a file that I have in place. So,&nbsp;
character types, I have got lines in which&nbsp;&nbsp;

00:07:07.120 --> 00:07:12.400
we have got various strings. So, I have got&nbsp;
a beginning of the line with something and&nbsp;&nbsp;

00:07:12.400 --> 00:07:20.000
ending also with something intentionally so that&nbsp;
those strings will be matched appropriately. So,&nbsp;&nbsp;

00:07:20.000 --> 00:07:25.440
I have got a lower letter, lowercase letter, I&nbsp;
have got uppercase letter, I have got a digit,&nbsp;&nbsp;

00:07:25.440 --> 00:07:31.760
and then I also have a non-printable character&nbsp;
like Ctrl + C. And here also there is a tab&nbsp;&nbsp;

00:07:31.760 --> 00:07:38.160
character that has been used and so on. And there&nbsp;
is a blank space here in front of it. So, and then&nbsp;&nbsp;

00:07:38.160 --> 00:07:42.640
there is an empty line also in the middle.
So, let us see how we can pick these lines by&nbsp;&nbsp;

00:07:42.640 --> 00:07:48.720
using the character sets which come with a&nbsp;
double square bracket and colons separating&nbsp;&nbsp;

00:07:48.720 --> 00:07:52.880
the name of the character set that we are&nbsp;
using. So, in all of them I will use the same&nbsp;&nbsp;

00:07:52.880 --> 00:08:03.760
pattern where we will use a cat chartypes&nbsp;
pipe grep. Now, let us use this pattern.&nbsp;&nbsp;

00:08:07.920 --> 00:08:14.960
Here we would like to let us say pick alphabetic&nbsp;
characters. So, any line that would have an&nbsp;&nbsp;

00:08:14.960 --> 00:08:20.000
alphabetical character would be matched, and&nbsp;
you see that all the lines will be matched,&nbsp;&nbsp;

00:08:20.000 --> 00:08:25.840
except the blank line, because the bank line&nbsp;
has nothing in it, so that has been skipped.
&nbsp;

00:08:30.960 --> 00:08:37.520
Next, the alphanum, that is lines which&nbsp;
would have alphanumeric characters will be&nbsp;&nbsp;

00:08:37.520 --> 00:08:44.160
matched. And you see that it is the same output&nbsp;
as the previous one. And it has also skipped&nbsp;&nbsp;

00:08:44.160 --> 00:08:53.840
the empty line because it has no alphanumeric&nbsp;
character that can be matched on that line.
&nbsp;

00:08:54.400 --> 00:09:00.000
Now, let us say I would like to have the&nbsp;
alphabetical character in the beginning of&nbsp;&nbsp;

00:09:00.000 --> 00:09:07.440
the string. Now, you see that only some of the&nbsp;
lines are showing up. So, if you see hello and&nbsp;&nbsp;

00:09:07.440 --> 00:09:12.080
then l and capital L these are getting matched&nbsp;
because they have an alphabetical character at the&nbsp;&nbsp;

00:09:12.080 --> 00:09:17.600
beginning, but the remaining lines do not have. It&nbsp;
has 5 and it has a 4 and this fellow has a control&nbsp;&nbsp;

00:09:17.600 --> 00:09:22.320
c and there is a empty character here null and&nbsp;
this is a comma here and there is a blank. So,&nbsp;&nbsp;

00:09:22.320 --> 00:09:26.000
none of them are actually alphabetical&nbsp;
characters, so they are all skipped.
&nbsp;

00:09:26.720 --> 00:09:32.000
Now, you could also ask for the alphabetical&nbsp;
character to be at the end of the&nbsp;&nbsp;

00:09:32.000 --> 00:09:38.240
line. And you will see that only some of the lines&nbsp;
are being shown, the one with a g, capital H and a&nbsp;&nbsp;

00:09:38.240 --> 00:09:43.600
small h. The remaining lines are not shown because&nbsp;
here it is a 2 which is a digit, and here it is a&nbsp;&nbsp;

00:09:43.600 --> 00:09:50.240
tab character and here it is a dot and here there&nbsp;
is a null and here there is an equal to sign, and&nbsp;&nbsp;

00:09:50.800 --> 00:09:54.960
here again, there is a control character. 
So the all of those have been skipped.&nbsp;&nbsp;

00:09:54.960 --> 00:09:58.800
And we have got only the first three lines&nbsp;
which have an alphabetical character in the end.&nbsp;&nbsp;

00:09:59.520 --> 00:10:03.600
So, you now see that alphabetical character can be&nbsp;
matched either at the beginning or anywhere in the&nbsp;&nbsp;

00:10:03.600 --> 00:10:10.080
line or at the end and you need to be watchful&nbsp;
which ones are suitable for your purpose.
&nbsp;

00:10:11.360 --> 00:10:15.120
Now, we can also look at the alphanumeric&nbsp;
character at the beginning of the line.&nbsp;&nbsp;

00:10:15.760 --> 00:10:20.880
And you see that it captures a little bit more&nbsp;
number of lines. So, the first character can&nbsp;&nbsp;

00:10:20.880 --> 00:10:28.080
be either an alphabetical or a numeric one, but&nbsp;
not a space or a null or a punctuation mark or&nbsp;&nbsp;

00:10:28.080 --> 00:10:32.320
a control character. So, those lines have been&nbsp;
skipped, the remaining ones have been shown.&nbsp;&nbsp;

00:10:32.880 --> 00:10:37.760
Now, you could also ask for an alphanumerical&nbsp;
character at the end of a line.&nbsp;&nbsp;

00:10:37.760 --> 00:10:44.800
And you see that again those have g or H or small&nbsp;
h or 2 are being shown, but the once which control&nbsp;&nbsp;

00:10:44.800 --> 00:10:50.080
character or a punctuation or a null or a equal&nbsp;
to sign, etc., they are all being skipped.
&nbsp;

00:10:50.080 --> 00:10:57.120
You can now look for lines that contain digits&nbsp;
anywhere in the line. And you could also ask&nbsp;&nbsp;

00:10:57.120 --> 00:11:03.600
the digit should be at the beginning of the&nbsp;
line or it should be at the end of the line.&nbsp;&nbsp;

00:11:03.600 --> 00:11:09.360
So, you could see that when you do not provide any&nbsp;
anchor, it would match anywhere in the line. So,&nbsp;&nbsp;

00:11:09.360 --> 00:11:14.960
here the 5 is somewhere in the middle of the&nbsp;
line, here it is in the beginning of the line. And&nbsp;&nbsp;

00:11:14.960 --> 00:11:19.040
in the case you provide an anchor with the hat, it&nbsp;
means it has to be matched only in the beginning&nbsp;&nbsp;

00:11:19.040 --> 00:11:25.440
of the line. So, the 5g and 42 are being matched.&nbsp;
And when you say end of the line as an anchor,&nbsp;&nbsp;

00:11:25.440 --> 00:11:32.240
then only the 42 line will be shown as matched&nbsp;
line from the file chartypes dot txt.
&nbsp;

00:11:32.800 --> 00:11:39.280
Now, there are some control characters that I have&nbsp;
placed in this file. And we could see whether you&nbsp;&nbsp;

00:11:39.280 --> 00:11:43.200
could pick the lines that contain the control&nbsp;
characters. And you see that these are the three&nbsp;&nbsp;

00:11:43.200 --> 00:11:50.960
lines. So here I have got a tab character and&nbsp;
here I have got a control c sitting here and here&nbsp;&nbsp;

00:11:50.960 --> 00:11:56.080
also I have got a control character sitting in the&nbsp;
front. So, those three lines only have been picked&nbsp;&nbsp;

00:11:56.080 --> 00:12:02.560
up. Now, you could ask a reverse question saying&nbsp;
that I do not want any control character.
&nbsp;

00:12:07.520 --> 00:12:14.720
Now, you could also ask that you would like&nbsp;
to have only the lines which do not contain&nbsp;&nbsp;

00:12:14.720 --> 00:12:19.520
the control character and the minus v option&nbsp;
would actually give you the opposite effect&nbsp;&nbsp;

00:12:19.520 --> 00:12:23.840
where the lines that are not matching are&nbsp;
shown. And you see that the remaining lines&nbsp;&nbsp;

00:12:23.840 --> 00:12:28.160
include the empty line are being shown.
Now, you could also look for any punctuation&nbsp;&nbsp;

00:12:28.160 --> 00:12:33.280
characters to be matched.&nbsp;
So, let us look at that punct&nbsp;&nbsp;

00:12:34.640 --> 00:12:39.520
would match for all punctuation characters. So,&nbsp;
all those lines which have punctuation characters,&nbsp;&nbsp;

00:12:39.520 --> 00:12:44.480
colon is one of the punctuation characters, so&nbsp;
that has been matched nicely. And almost every&nbsp;&nbsp;

00:12:44.480 --> 00:12:49.360
line has that except the empty line, so empty&nbsp;
line has been skipped. So, now I give an anchor&nbsp;&nbsp;

00:12:49.360 --> 00:12:52.880
at the beginning of the line. 
So, only those lines at the beginning&nbsp;&nbsp;

00:12:52.880 --> 00:12:57.120
contain a punctuation mark will be shown. So,&nbsp;
we have got a comma there in the first, this&nbsp;&nbsp;

00:12:57.120 --> 00:13:03.200
line here so that has been matched. And you could&nbsp;
also ask for a line that ends with a punctuation&nbsp;&nbsp;

00:13:03.200 --> 00:13:08.080
and you see that the ones with have a dot and&nbsp;
the equal to sign have been matched. So, the&nbsp;&nbsp;

00:13:08.080 --> 00:13:13.680
punctuation marks without specifying what those&nbsp;
marks are can also be used as a character set.
&nbsp;

00:13:16.160 --> 00:13:24.400
Now, the case of the character also can be used.&nbsp;
So, if I want to have matching lines that contain&nbsp;&nbsp;

00:13:25.360 --> 00:13:31.680
only, that contain lower case characters, so you&nbsp;
would see that all the lines except the empty line&nbsp;&nbsp;

00:13:31.680 --> 00:13:37.600
are being shown because they all contain some&nbsp;
lowercase letters. And I would put an anchor here&nbsp;&nbsp;

00:13:38.800 --> 00:13:43.920
to show that the lowercase characters should be&nbsp;
matched at the beginning of the line. And so the&nbsp;&nbsp;

00:13:43.920 --> 00:13:49.840
hello and l will be getting matched there with&nbsp;
a capital, with a small h and l and I could give&nbsp;&nbsp;

00:13:49.840 --> 00:13:58.000
an anchor to indicate that I want the matching&nbsp;
to be done at the end and the 5g line and the h&nbsp;&nbsp;

00:13:58.000 --> 00:14:02.880
in the end will be matched because they contain a&nbsp;
lowercase character at the end of the string.
&nbsp;

00:14:05.040 --> 00:14:10.080
You could also look at the same kind of&nbsp;
analysis using the uppercase characters.&nbsp;&nbsp;

00:14:12.000 --> 00:14:16.560
So, all those lines which contain any uppercase&nbsp;
character will be displayed and you see that&nbsp;&nbsp;

00:14:16.560 --> 00:14:21.840
we do not have uppercase characters used&nbsp;
very much so only three lines are used. So,&nbsp;&nbsp;

00:14:21.840 --> 00:14:27.760
you have got a capital H here, capital L here and&nbsp;
capital C here. So, only three lines have been&nbsp;&nbsp;

00:14:27.760 --> 00:14:32.880
matched. And I will put an anchor here. 
So, only the ones which have a starting&nbsp;&nbsp;

00:14:33.680 --> 00:14:37.360
with an uppercase character will be shown.&nbsp;
So, capital L is getting matched there.&nbsp;&nbsp;

00:14:38.080 --> 00:14:42.800
And I put a dollar here and remove&nbsp;
the hat. So, I get a matching&nbsp;&nbsp;

00:14:42.800 --> 00:14:46.400
where the ending of the line will be a&nbsp;
capital letter that would be the capital H.&nbsp;&nbsp;

00:14:47.440 --> 00:14:53.120
So, now you see that you could also specify&nbsp;
the matching pattern using a character set&nbsp;&nbsp;

00:14:53.120 --> 00:14:59.200
that contains the uppercase characters.
The alphanumerical characters as well as&nbsp;&nbsp;

00:14:59.200 --> 00:15:04.800
the punctuation marks are combined together as&nbsp;
printable characters, because they can display&nbsp;&nbsp;

00:15:04.800 --> 00:15:10.240
on the screen and the control characters are&nbsp;
then avoided. So, you can actually use the class,&nbsp;&nbsp;

00:15:10.240 --> 00:15:15.760
character class called print to indicate that you&nbsp;
would like to match only printable characters.&nbsp;&nbsp;

00:15:16.400 --> 00:15:22.320
And when you want to display you would see that&nbsp;
every line except the blank line has been matched,&nbsp;&nbsp;

00:15:22.320 --> 00:15:27.680
because except the blank line every other line&nbsp;
has some printable characters or other.
&nbsp;

00:15:27.680 --> 00:15:31.440
Now, you could also ask for a printable&nbsp;
character to be at the beginning of the line.&nbsp;&nbsp;

00:15:32.560 --> 00:15:36.480
And you would see that those lines which&nbsp;
have a control character in the beginning&nbsp;&nbsp;

00:15:36.480 --> 00:15:43.360
have been skipped. Then you could also ask for the&nbsp;
printable character to be the end of the line. And&nbsp;&nbsp;

00:15:43.360 --> 00:15:47.520
you see that some of the lines which contain a&nbsp;
control character at the end are skipped. 
&nbsp;

00:15:47.520 --> 00:15:53.920
So, here, for example, here there is a control&nbsp;
character at the end that has been skipped. And&nbsp;&nbsp;

00:15:53.920 --> 00:15:58.400
here there is a control character in the beginning&nbsp;
and that has been kept because the printable&nbsp;&nbsp;

00:15:58.400 --> 00:16:07.840
character is matched only in the end and therefore&nbsp;
in the beginning can be anything else.
&nbsp;

00:16:18.160 --> 00:16:23.680
Now, there are some characters which give you&nbsp;
a blank space like a space character or a tab&nbsp;&nbsp;

00:16:23.680 --> 00:16:28.560
character, so they can also be matched. So,&nbsp;
these are the whitespace characters. And you&nbsp;&nbsp;

00:16:28.560 --> 00:16:33.440
would see that except the empty line,&nbsp;
all the lines contain some whitespace&nbsp;&nbsp;

00:16:33.440 --> 00:16:38.160
or other and that has been matched.
And you could also ask for the anchor&nbsp;&nbsp;

00:16:39.440 --> 00:16:48.240
to show that in the beginning or to show that in&nbsp;
the end. So, you see that there is a blank space&nbsp;&nbsp;

00:16:48.240 --> 00:16:53.040
that is available at the beginning or at the end&nbsp;
of these two lines so they are being shown, but&nbsp;&nbsp;

00:16:53.040 --> 00:16:57.360
the remaining lines have the blank space somewhere&nbsp;
in the middle so those are being picked up.
&nbsp;

00:16:57.920 --> 00:17:02.320
Now, there is a character case called space&nbsp;
that can also be used to pick up lines that&nbsp;&nbsp;

00:17:02.320 --> 00:17:08.000
contain some whitespace. And you could also ask&nbsp;
for it to have the beginning with the whitespace&nbsp;&nbsp;

00:17:08.560 --> 00:17:12.960
or the end with this whitespace. Now, this is&nbsp;
not very different from the blank space except&nbsp;&nbsp;

00:17:14.240 --> 00:17:22.160
that there are more whitespace characters than&nbsp;
what we have used. And you can see what type&nbsp;&nbsp;

00:17:22.160 --> 00:17:27.680
of a whitespace that is allowed for your input&nbsp;
file and accordingly filter them out using the&nbsp;&nbsp;

00:17:27.680 --> 00:17:33.840
difference between these two character sets.
Now, the counter class called graph is used to&nbsp;&nbsp;

00:17:33.840 --> 00:17:40.480
match any non-space character. So, you can&nbsp;
see that it, every line except the blank&nbsp;&nbsp;

00:17:40.480 --> 00:17:47.440
line has some character which is not a space and&nbsp;
therefore that is getting matched here. And you&nbsp;&nbsp;

00:17:47.440 --> 00:17:54.000
could then have that as an anchor in the front.&nbsp;
And you could see that those lines that contain&nbsp;&nbsp;

00:17:56.000 --> 00:18:00.080
any non-space character are&nbsp;
being displayed in the front. 
&nbsp;

00:18:00.080 --> 00:18:07.600
So, some of them which contain a control C that&nbsp;
has been skipped here, a blank that has been&nbsp;&nbsp;

00:18:08.320 --> 00:18:10.480
skipped here, so the&nbsp;
remaining ones only are there,&nbsp;&nbsp;

00:18:12.160 --> 00:18:16.880
only the remaining ones are being displayed. And I&nbsp;
could also put an anchor at the end and you would&nbsp;&nbsp;

00:18:16.880 --> 00:18:24.000
see that the lines that contain a blank space at&nbsp;
the end are skipped. So, a non-space character&nbsp;&nbsp;

00:18:24.720 --> 00:18:28.560
is tolerated at the end of the line.
Now, let us say we would like to skip&nbsp;&nbsp;

00:18:28.560 --> 00:18:32.960
all the empty lines. So that&nbsp;
can be done using this option.&nbsp;&nbsp;

00:18:39.040 --> 00:18:46.880
So, what happens is that the matching lines for&nbsp;
the two anchor characters side by side would&nbsp;&nbsp;

00:18:47.600 --> 00:18:53.520
give empty lines and minus we would say that do&nbsp;
not print that, print whatever does not match the&nbsp;&nbsp;

00:18:53.520 --> 00:18:59.920
empty line. So, the non-empty lines are getting&nbsp;
printed out now. And the empty lines if you want&nbsp;&nbsp;

00:18:59.920 --> 00:19:03.840
to print, there is nothing funny about it just&nbsp;
an empty line. So, that is not very useful.
&nbsp;

00:19:03.840 --> 00:19:08.240
But the with the minus v option, you could&nbsp;
actually remove the empty lines from an input&nbsp;&nbsp;

00:19:08.240 --> 00:19:13.680
string, input stream and that is quite useful&nbsp;
in processing where you expect something to be&nbsp;&nbsp;

00:19:13.680 --> 00:19:17.600
there on the line and you do not want to have&nbsp;
empty lines coming in. So, you could use this&nbsp;&nbsp;

00:19:17.600 --> 00:19:22.480
feature of minus v, and then the two anchors&nbsp;
side by side for the beginning and the end,&nbsp;&nbsp;

00:19:22.480 --> 00:19:28.560
so that you skip empty lines.
Time to time we are expected to pick up patterns&nbsp;&nbsp;

00:19:29.200 --> 00:19:35.200
from a given text file and then analyze them if&nbsp;
they correspond to certain fields. So, now let&nbsp;&nbsp;

00:19:35.200 --> 00:19:40.960
us look at an example file and see whether we can&nbsp;
pick up such patterns using the grep command.
&nbsp;

00:19:40.960 --> 00:19:47.440
So, here I am providing a random piece of text&nbsp;
which contains certain patterns. So, as we know,&nbsp;&nbsp;

00:19:47.440 --> 00:19:53.440
the Aadhar card numbers have about 12 digits.&nbsp;
So, I am giving that as one example in one line.&nbsp;&nbsp;

00:19:54.000 --> 00:19:59.840
And then the pin codes usually have six digits&nbsp;
so that of IIT Madras is a six digit one, 600036.&nbsp;&nbsp;

00:20:01.120 --> 00:20:06.240
There is no other location in Chennai that uses&nbsp;
the same pin code. So, I am giving that as one&nbsp;&nbsp;

00:20:06.240 --> 00:20:13.360
example. And then the phone numbers for mobile&nbsp;
phones are 10 digit and without the country code&nbsp;&nbsp;

00:20:13.360 --> 00:20:18.640
or the zero for a city dialing the landline&nbsp;
numbers also are 10 digits for the cities.&nbsp;&nbsp;

00:20:18.640 --> 00:20:22.960
So, I am giving that as an example.
The roll numbers in IIT for regular students&nbsp;&nbsp;

00:20:23.520 --> 00:20:28.480
are following the pattern where the first two&nbsp;
letters correspond to the department code.&nbsp;&nbsp;

00:20:28.480 --> 00:20:33.040
And then the two digits correspond to the year&nbsp;
of joining. And then there is a program code&nbsp;&nbsp;

00:20:33.040 --> 00:20:38.000
which is in one letter followed by three digits&nbsp;
corresponding to the roll number within the class.&nbsp;&nbsp;

00:20:38.960 --> 00:20:45.920
And it is not necessary that we need to give the&nbsp;
URLs of our websites with the protocol like HTTPS&nbsp;&nbsp;

00:20:45.920 --> 00:20:52.960
or HTTP, but if you just give a string where there&nbsp;
is a dot and on either sides of the dot there is&nbsp;&nbsp;

00:20:52.960 --> 00:20:58.800
a word which is alphanumeric, then that is also a&nbsp;
valid URL. And you would have seen on your mobile&nbsp;&nbsp;

00:20:58.800 --> 00:21:04.240
phone that such strings are automatically&nbsp;
made clickable and they could also be,&nbsp;&nbsp;

00:21:04.880 --> 00:21:08.560
and they could be interpreted as URLs.
So, now, let us see whether we can pick these&nbsp;&nbsp;

00:21:08.560 --> 00:21:13.520
numbers from this text using the grep command.&nbsp;
Now, it would not work if any of these are&nbsp;&nbsp;

00:21:13.520 --> 00:21:19.600
spanning across two lines, because grep would use&nbsp;
only one line at a time for processing. But with&nbsp;&nbsp;

00:21:19.600 --> 00:21:25.200
that limitation very quickly we can actually put&nbsp;
the grep knowledge that we have earned till now&nbsp;&nbsp;

00:21:26.000 --> 00:21:30.960
to some good use already.
So, first, I would like to pick up the numbers&nbsp;&nbsp;

00:21:30.960 --> 00:21:37.360
which are having exactly 12 digits long so that&nbsp;
the other card could come out of the text. So, I&nbsp;&nbsp;

00:21:37.360 --> 00:21:44.080
would like to always keep printing the original&nbsp;
text so that it is useful for you. So, egrep&nbsp;&nbsp;

00:21:46.480 --> 00:21:51.440
and then the pattern will be given. The pattern&nbsp;
should be such that any digit should be matched&nbsp;&nbsp;

00:21:53.200 --> 00:22:00.080
and it should have exactly 12 occurrences. So,&nbsp;
12 occurrences should be there. And you see that&nbsp;&nbsp;

00:22:00.080 --> 00:22:05.520
we have identified the Aadhar card as a&nbsp;
matching pattern within the first line. So,&nbsp;&nbsp;

00:22:05.520 --> 00:22:09.680
no other line is getting displayed. So, that&nbsp;
means that there is no confusion there.
&nbsp;

00:22:10.400 --> 00:22:18.880
Now, let us say we would like to pick up the pin&nbsp;
code. So, now you see that pin code is six digit,&nbsp;&nbsp;

00:22:18.880 --> 00:22:23.360
so I want to pick those numbers that contain&nbsp;
six digits. Now, you see that there is a&nbsp;&nbsp;

00:22:23.360 --> 00:22:28.960
problem here. It is actually picking up numbers&nbsp;
which are matching six digits of the Aadhar card&nbsp;&nbsp;

00:22:28.960 --> 00:22:32.880
as well as for the phone number. 
Now, how do I pick only the six digits&nbsp;&nbsp;

00:22:32.880 --> 00:22:38.880
and not more or not less, and that can be done&nbsp;
using the word boundary. So, now, let us say that&nbsp;&nbsp;

00:22:38.880 --> 00:22:46.480
before and after the six digits, there must be&nbsp;
a word boundary. And now you see that it would&nbsp;&nbsp;

00:22:46.480 --> 00:22:51.520
actually identify only the line that corresponds&nbsp;
to the pin code. The phone number and the Aadhar&nbsp;&nbsp;

00:22:51.520 --> 00:22:57.200
card are not coming because they do not have a&nbsp;
word boundary after the six digits are matched.
&nbsp;

00:23:01.440 --> 00:23:06.400
Now, I would like to identify what looks like a&nbsp;
roll number. Now, you see that the roll number&nbsp;&nbsp;

00:23:06.400 --> 00:23:12.880
is actually a mix of both alphabetical as&nbsp;
well as the digits. So, it is a bit painful.&nbsp;&nbsp;

00:23:13.680 --> 00:23:21.840
Now, alphanumerical characters of that particular&nbsp;
length can also be tried out let us do that.
&nbsp;

00:23:28.160 --> 00:23:31.600
So, let us try out the&nbsp;
alphanumerical characters alnum&nbsp;&nbsp;

00:23:32.960 --> 00:23:38.720
and we see that it is actually having&nbsp;
a length of eight. So, I put an 8 here.&nbsp;&nbsp;

00:23:39.600 --> 00:23:47.200
So, any eight character long alphanumerical string&nbsp;
would be matched and you see that is actually not&nbsp;&nbsp;

00:23:47.200 --> 00:23:54.480
working out, because it is matching given regular&nbsp;
words which do not have specific digits. Now, no&nbsp;&nbsp;

00:23:54.480 --> 00:24:01.600
point even asking for a word boundary because word&nbsp;
boundary would also catch words which are exactly&nbsp;&nbsp;

00:24:01.600 --> 00:24:08.240
eight characters long so even that does not work.&nbsp;
So, we need some other strategy that is where&nbsp;&nbsp;

00:24:08.240 --> 00:24:12.960
the character set that we have discussed would&nbsp;
come off use. So, now let us try that out.
&nbsp;

00:24:16.000 --> 00:24:21.920
So, what we would do is that we would&nbsp;
use a word boundary and then the&nbsp;&nbsp;

00:24:22.560 --> 00:24:30.480
alphabetical characters should occur exactly&nbsp;
two times following by that a digit has to come&nbsp;&nbsp;

00:24:31.760 --> 00:24:36.960
exactly two times and then an&nbsp;
alphabetical character has to come,&nbsp;&nbsp;

00:24:37.920 --> 00:24:46.320
and after that again a digit has to come exactly&nbsp;
three times, after that there is again a word&nbsp;&nbsp;

00:24:46.320 --> 00:24:52.480
boundary. So, you see that the pattern when you&nbsp;
type it is quite long, but it is quite logical.
&nbsp;

00:24:52.480 --> 00:24:55.760
What we are doing is I am&nbsp;
asking for a word boundary,&nbsp;&nbsp;

00:24:56.480 --> 00:25:02.560
after that I am asking for an alphabetical&nbsp;
character coming exactly twice, and then I am&nbsp;&nbsp;

00:25:02.560 --> 00:25:09.440
asking for a digit that comes exactly twice, and&nbsp;
then again an alphabetical character, only one,&nbsp;&nbsp;

00:25:10.400 --> 00:25:17.120
and then I have got a digit that comes exactly&nbsp;
thrice, after that again a word boundary. 
&nbsp;

00:25:17.120 --> 00:25:22.160
So, this is a pattern that we are giving and you&nbsp;
see that it identifies exactly the roll number and&nbsp;&nbsp;

00:25:22.160 --> 00:25:29.120
nothing else. So, by carefully using the character&nbsp;
sets, we can actually identify the pattern of the&nbsp;&nbsp;

00:25:29.120 --> 00:25:34.480
string that we are trying to pick up. Now,&nbsp;
for the URLs also we can actually use the&nbsp;&nbsp;

00:25:34.480 --> 00:25:40.080
same kind of a strategy. What is the strategy? 
So, you know that the protocols are not necessary&nbsp;&nbsp;

00:25:40.080 --> 00:25:45.920
to be used now. Even the names like this also&nbsp;
are possible. So, what we would do is as follows.&nbsp;&nbsp;

00:25:49.280 --> 00:25:56.160
And then a alphanumeric character&nbsp;
can come any number of times, but not&nbsp;&nbsp;

00:25:57.360 --> 00:26:03.040
zero, after that a dot has to come, but&nbsp;
the dot has to be also escaped. And again&nbsp;&nbsp;

00:26:04.800 --> 00:26:11.760
alphanumerical character can be there and that&nbsp;
also has to come once or more, but definitely&nbsp;&nbsp;

00:26:11.760 --> 00:26:19.920
not zero times and then the word boundary.
So, you see now that it identifies the two URLs&nbsp;&nbsp;

00:26:19.920 --> 00:26:30.320
quite nicely. And so you can see that the usage&nbsp;
of the word boundary here and then the plus sign&nbsp;&nbsp;

00:26:30.320 --> 00:26:36.560
which is available in the extended regular&nbsp;
expression engine under egrep and then the&nbsp;&nbsp;

00:26:36.560 --> 00:26:40.640
backslash to escape the meaning of the&nbsp;
dot so that the dot is matched as it is,&nbsp;&nbsp;

00:26:41.520 --> 00:26:47.600
and then again, a word boundary to signal that&nbsp;
is at the end of a particular word would actually&nbsp;&nbsp;

00:26:47.600 --> 00:26:53.760
help you in identifying the URLs quite easily. 
Now, I have used only alphanumerical characters.&nbsp;&nbsp;

00:26:53.760 --> 00:26:59.760
Underscore is also an allowed character. So, you&nbsp;
can actually expand the scope of this matching&nbsp;&nbsp;

00:26:59.760 --> 00:27:05.840
to include every possible URL that can come in&nbsp;
a random text that you are not expecting.
&nbsp;

00:27:06.880 --> 00:27:15.200
Now, time to time, there is a need for us to trim&nbsp;
a text from the top to the bottom or sideways. So,&nbsp;&nbsp;

00:27:15.200 --> 00:27:20.400
top to bottom, we have already learned how to&nbsp;
trim by using the command a head and tail. So,&nbsp;&nbsp;

00:27:20.400 --> 00:27:25.920
the top end lines of a text file can be picked&nbsp;
up using the head command, the bottom end lines&nbsp;&nbsp;

00:27:25.920 --> 00:27:30.720
can be picked up using the tail command. But what&nbsp;
about trimming the text from the left and right&nbsp;&nbsp;

00:27:31.280 --> 00:27:35.040
where we can use either the number of&nbsp;
fields or the number of characters.&nbsp;&nbsp;

00:27:35.040 --> 00:27:38.880
So, for that, there is a function that is&nbsp;
available. So, the command is called cut.
&nbsp;

00:27:38.880 --> 00:27:42.800
So, when you use man cut, you&nbsp;
would see that it is enabling&nbsp;&nbsp;

00:27:42.800 --> 00:27:48.320
a horizontal trimming of the lines and that&nbsp;
is used to remove sections from each of the&nbsp;&nbsp;

00:27:48.320 --> 00:27:55.280
files and it is going line by line. And it can&nbsp;
actually trim using either the characters or&nbsp;&nbsp;

00:27:55.280 --> 00:27:59.760
fields, but for any field you also need&nbsp;
to know what is the character used for the&nbsp;&nbsp;

00:27:59.760 --> 00:28:04.960
delimiter so minus d option also has to be&nbsp;
there. And the default is tab, but you can&nbsp;&nbsp;

00:28:04.960 --> 00:28:10.320
provide any other delimiting character.
So, now I have prepared a simple text file&nbsp;&nbsp;

00:28:10.960 --> 00:28:15.840
using which we can actually start trimming&nbsp;
to understand the usage of the cut command.&nbsp;&nbsp;

00:28:17.680 --> 00:28:24.560
So, fields dot txt is a simple three line file&nbsp;
in which I have got fields like this. So, 1, 2,&nbsp;&nbsp;

00:28:24.560 --> 00:28:31.360
3, 4 and then a semicolon, after that hello world&nbsp;
has a blank, after that there is a comma. So,&nbsp;&nbsp;

00:28:31.360 --> 00:28:37.360
you can see that you could use the semicolon or&nbsp;
the comma or the blank space as a field separator,&nbsp;&nbsp;

00:28:38.240 --> 00:28:44.960
and you can also use the number of characters as a&nbsp;
way to cut. So, now let us go and inspect the how&nbsp;&nbsp;

00:28:44.960 --> 00:28:48.080
the cut command can be done.
Now, it can be used both ways. So,&nbsp;&nbsp;

00:28:48.080 --> 00:28:54.560
you can actually use cut fields dot&nbsp;
txt and then you can actually give some&nbsp;&nbsp;

00:28:55.600 --> 00:29:02.240
options how to cut, so minus c is the number of&nbsp;
characters and 1 to 4 tells you that from 1 to 4&nbsp;&nbsp;

00:29:02.240 --> 00:29:07.360
characters from the beginning should be taken out&nbsp;
and displayed. So you can see that the first four&nbsp;&nbsp;

00:29:07.360 --> 00:29:13.360
characters have been taken out and displayed.&nbsp;
Now, you could also say that I want from&nbsp;&nbsp;

00:29:14.480 --> 00:29:20.000
5 to 8 and I have got the next four&nbsp;
characters coming on the screen.
&nbsp;

00:29:20.000 --> 00:29:26.000
Now, this does not pay attention to what was the&nbsp;
field. It just goes as a series of characters and&nbsp;&nbsp;

00:29:26.000 --> 00:29:33.440
picks up the character sequence that you want so&nbsp;
1 to 4 or 5 to 8 or whatever. And if you do not&nbsp;&nbsp;

00:29:33.440 --> 00:29:41.360
specify the initial part, it will actually assume&nbsp;
that you are going to have the, from the beginning&nbsp;&nbsp;

00:29:41.360 --> 00:29:46.240
okay. And if you do not specify the ending, it&nbsp;
will also assume that you want it till the end.&nbsp;&nbsp;

00:29:47.520 --> 00:29:52.960
So, the option is there for the hyphen either the&nbsp;
left side of the hyphen or the right hand side of&nbsp;&nbsp;

00:29:52.960 --> 00:29:58.160
the hyphen can be can be provided. If you provide&nbsp;
both then it will be indicating as a range.
&nbsp;

00:30:00.480 --> 00:30:09.920
Now, let us use a delimiter to pick up some of the&nbsp;
fields. So, let us use it as a piped command. So,&nbsp;&nbsp;

00:30:10.880 --> 00:30:17.200
cut can take the input from a pipe. So, we will do&nbsp;
that now. And let us use the delimiter as a space.&nbsp;&nbsp;

00:30:18.240 --> 00:30:22.080
So, now you will see that if I use the delimiter&nbsp;
as a space, then this will be the first&nbsp;&nbsp;

00:30:22.080 --> 00:30:26.640
field and this is the second field. Now,&nbsp;
I want to print only the first field. 
&nbsp;

00:30:27.760 --> 00:30:32.800
Now, you see that it comes out quite nicely.&nbsp;
And the length of each of these fields need&nbsp;&nbsp;

00:30:32.800 --> 00:30:38.000
not be same. So which means that when the&nbsp;
number of characters is not what is uniform,&nbsp;&nbsp;

00:30:38.000 --> 00:30:42.480
but the way the characters are&nbsp;
separated is what is uniform,&nbsp;&nbsp;

00:30:42.480 --> 00:30:47.200
then using space as a delimiter you can pick&nbsp;
the first field. You can also pick the second&nbsp;&nbsp;

00:30:47.200 --> 00:30:51.680
field and you see that the second half of&nbsp;
the text is coming up onto the screen.
&nbsp;

00:30:54.160 --> 00:30:57.680
Now, if you want both, you can also&nbsp;
get it. So, then you have got both the,&nbsp;&nbsp;

00:30:57.680 --> 00:31:02.480
entire lines coming up, so that is actually not&nbsp;
meaningful in this case. But in some situations&nbsp;&nbsp;

00:31:02.480 --> 00:31:07.280
where there are more than two fields, then you&nbsp;
can actually take part of those fields also.
&nbsp;

00:31:07.840 --> 00:31:16.080
Now, let us use the semicolon as a delimiter. And&nbsp;
you would see that when I use semicolon, then the&nbsp;&nbsp;

00:31:16.080 --> 00:31:23.760
first field is this number, the second field is a&nbsp;
string that contains a comma also in between. So,&nbsp;&nbsp;

00:31:23.760 --> 00:31:28.480
let us check that out. And you see that only the&nbsp;
numbers are coming when I asked the first field.&nbsp;&nbsp;

00:31:29.040 --> 00:31:34.640
And when I asked the second field, I am&nbsp;
getting the string, and then the comma. So,&nbsp;&nbsp;

00:31:34.640 --> 00:31:41.280
this is quite nice. You can change the delimiter&nbsp;
and cut fields as per the delimiter, and pick up&nbsp;&nbsp;

00:31:41.280 --> 00:31:48.320
only those fields that you would like to have.
So, similarly, we can actually also use comma as a&nbsp;&nbsp;

00:31:48.320 --> 00:31:53.440
delimiter. And you see that when I have comma as&nbsp;
a delimiter, the second field will contain the&nbsp;&nbsp;

00:31:53.440 --> 00:31:58.560
line number. So, I would like to take the second&nbsp;
field, and you see only the line numbers are being&nbsp;&nbsp;

00:31:58.560 --> 00:32:03.840
displayed here, because after the comma, this is&nbsp;
the second field, this is the second field. And if&nbsp;&nbsp;

00:32:03.840 --> 00:32:07.920
you want the first field before the comma, the&nbsp;
rest of it actually is coming onto the screen,&nbsp;&nbsp;

00:32:07.920 --> 00:32:11.440
which actually does not have the&nbsp;
same length for each of the lines.
&nbsp;

00:32:12.000 --> 00:32:18.080
So, the comma, the semicolon, the space or&nbsp;
the tab, all of these can be used as field&nbsp;&nbsp;

00:32:18.080 --> 00:32:24.480
separators. So, look at the input stream once&nbsp;
with your own eyes to see what is the delimiter&nbsp;&nbsp;

00:32:24.480 --> 00:32:27.840
that was used by the program which is&nbsp;
throwing that particular stream at you.&nbsp;&nbsp;

00:32:28.560 --> 00:32:33.200
And then once you understand, you can go ahead and&nbsp;
use the cut command to pick the fields that you&nbsp;&nbsp;

00:32:33.200 --> 00:32:38.800
want without having to tell the original developer&nbsp;
to provide them as you like so you can just cut&nbsp;&nbsp;

00:32:38.800 --> 00:32:45.120
and take what you need from the output stream.
Now, you can also combine the streams&nbsp;&nbsp;

00:32:45.840 --> 00:32:51.280
by piping them multiple times. Let us say I&nbsp;
would like to pick only the string in between&nbsp;&nbsp;

00:32:51.280 --> 00:32:56.240
the semicolon and the comma, so what I will&nbsp;
do is I will use semicolon as the first field&nbsp;&nbsp;

00:32:56.240 --> 00:33:00.800
separator and then comma as a second&nbsp;
time. So, let us look at that now.
&nbsp;

00:33:03.840 --> 00:33:10.160
So, I want to pick only this part. So what&nbsp;
I would do is, I would say cat fields,&nbsp;&nbsp;

00:33:10.160 --> 00:33:16.880
then cut the minus delimiter, I would first use&nbsp;
this, and take the first field, and then I would&nbsp;&nbsp;

00:33:16.880 --> 00:33:27.520
use comma as the delimiter, and again take the&nbsp;
first field. So, second field for the semicolon&nbsp;&nbsp;

00:33:27.520 --> 00:33:32.480
as delimiter because I want the second half of&nbsp;
it and then after that I will separate using the&nbsp;&nbsp;

00:33:32.480 --> 00:33:36.480
comma and then I will take the first half of it.&nbsp;
So, that is what I am meaning by this command.&nbsp;&nbsp;

00:33:36.480 --> 00:33:42.000
And you see that I am getting the string that is&nbsp;
exactly between the semicolon and the comma.
&nbsp;

00:33:43.040 --> 00:33:47.840
So, now, this is actually not bothering about&nbsp;
anything else. So, you can also achieve this&nbsp;&nbsp;

00:33:47.840 --> 00:33:52.960
to some extent using grep also. But in this&nbsp;
case we are looking at the text in a slightly&nbsp;&nbsp;

00:33:52.960 --> 00:33:58.080
different manner. We are looking at as a set of&nbsp;
fields that are separated and picking the fields&nbsp;&nbsp;

00:33:58.080 --> 00:34:03.040
which is slightly different way of looking&nbsp;
at than a grep command. But we can also try&nbsp;&nbsp;

00:34:03.040 --> 00:34:19.840
to see whether the grep would work to give the&nbsp;
same result. So, let us try that out now.
&nbsp;

00:34:27.280 --> 00:34:32.960
And you see that the grep command was able to&nbsp;
match exactly the part that you would like to&nbsp;&nbsp;

00:34:33.600 --> 00:34:38.400
match. Now, but you have not cut it off. So,&nbsp;
you have not yet trimmed the rest of it off.&nbsp;&nbsp;

00:34:38.400 --> 00:34:41.360
For the trimming part, you can&nbsp;
pass on the output of the grep to&nbsp;&nbsp;

00:34:42.480 --> 00:34:46.880
said command which we would learn in the&nbsp;
future classes, but for now you can see&nbsp;&nbsp;

00:34:46.880 --> 00:34:52.560
that you can also identify the string that you&nbsp;
want by using pattern matching quite well. But&nbsp;&nbsp;

00:34:52.560 --> 00:34:56.640
the cut command is very useful because you can&nbsp;
actually remove that portion and then go on to&nbsp;&nbsp;

00:34:57.200 --> 00:35:03.600
look at the output in a way that you would like&nbsp;
to parse it with any other tool later on.
&nbsp;

00:35:13.600 --> 00:35:20.400
Now, you could actually combine the concept&nbsp;
of cutting the text from left and right using&nbsp;&nbsp;

00:35:20.400 --> 00:35:26.240
the cut command and then the head and tail to&nbsp;
actually cut the lines from the top and the bottom&nbsp;&nbsp;

00:35:26.240 --> 00:35:31.760
to pick a particular entry from the input&nbsp;
string. So, let us try that out and I want&nbsp;&nbsp;

00:35:31.760 --> 00:35:36.480
to pick up only the welcome command line as&nbsp;
the text. So, what I would do is, I will cut&nbsp;&nbsp;

00:35:36.480 --> 00:35:41.120
it from the left and right first and after that&nbsp;
top and bottom. So, let us look at that now.
&nbsp;

00:35:43.600 --> 00:35:48.080
So, here I am getting the three lines. Now,&nbsp;
I would like to only have the second line.&nbsp;&nbsp;

00:35:48.080 --> 00:35:54.480
So, I would do like this, head minus n and then&nbsp;
two lines. The top two lines are being picked up.&nbsp;&nbsp;

00:35:54.480 --> 00:36:01.040
And in the top two lines I want the last line. So,&nbsp;
I would pick the last line coming out. And now you&nbsp;&nbsp;

00:36:01.040 --> 00:36:06.000
see that I have picked up exactly the string&nbsp;
welcome command line coming on to the screen&nbsp;&nbsp;

00:36:06.000 --> 00:36:12.000
and I have used many, many commands here.
So, I have catinated the contents of the file&nbsp;&nbsp;

00:36:12.000 --> 00:36:18.880
fields dot text and I have cut it using the field&nbsp;
separator semicolon and picked up the second field&nbsp;&nbsp;

00:36:18.880 --> 00:36:23.600
and after that I have again cut it using the comma&nbsp;
as a field separator and pick the first field&nbsp;&nbsp;

00:36:23.600 --> 00:36:27.680
and after that I have picked up the top two&nbsp;
lines and then from those top two lines I&nbsp;&nbsp;

00:36:27.680 --> 00:36:32.720
have taken the bottom most line and then displayed&nbsp;
it and we have got the string that we wanted.
&nbsp;

00:36:32.720 --> 00:36:36.560
So, you can actually combine&nbsp;
the commands in various ways to&nbsp;&nbsp;

00:36:37.360 --> 00:36:43.200
get the output that you are interested. And it&nbsp;
is up to our imagination to find the easiest way.&nbsp;&nbsp;

00:36:43.200 --> 00:36:46.720
And of course the most elegant way&nbsp;
would be when we are experts in&nbsp;&nbsp;

00:36:46.720 --> 00:36:52.640
all these commands for which a lot of practice&nbsp;
is required. So, keep practicing various&nbsp;&nbsp;

00:36:53.440 --> 00:36:58.080
of these commands and be thorough with&nbsp;
regular expressions so that you make the&nbsp;&nbsp;

00:36:58.080 --> 00:37:07.840
best use of the tools that are available&nbsp;
in the Linux command line environment.

