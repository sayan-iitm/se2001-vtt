WEBVTT
Kind: captions
Language: en

00:00:14.139 --> 00:00:18.599
Let us say we would like to inspect what are
all the variables that are present within

00:00:18.599 --> 00:00:19.609
the shell environment.

00:00:19.609 --> 00:00:26.890
We have already seen that in the past so you
could use a command like printenv, and you

00:00:26.890 --> 00:00:30.660
will see the whole bunch of stuff that is
displayed on the screen and you will see that

00:00:30.660 --> 00:00:36.449
there is a lot of variables that are available
which are now listed for us, you could also

00:00:36.449 --> 00:00:41.000
use the command env and that will also display
some of these.

00:00:41.000 --> 00:00:46.350
Now, there is a slightly better way of going
about inspecting what variables are present

00:00:46.350 --> 00:00:55.840
in the memory, that is by using a particular
command as follows echo and here what we will

00:00:55.840 --> 00:01:02.359
do is you put the exclamation mark followed
by any character, so the character starting

00:01:02.359 --> 00:01:10.110
with let us say so, this is a construction
to see what are the names of the variables,

00:01:10.110 --> 00:01:15.910
it starts with H and you see that these are
the variables and each of these now you can

00:01:15.910 --> 00:01:20.659
actually explore, the values.

00:01:20.659 --> 00:01:37.020
So, each of them can be done and so on, so
this is a very interesting command because

00:01:37.020 --> 00:01:42.409
it is actually giving you the names of the
variables rather than the value of the variable,

00:01:42.409 --> 00:01:48.240
the star actually is an expansion to tell
you that the name can be anything after H,

00:01:48.240 --> 00:01:52.260
so of course, you can also start with the
multiple characters, so you could actually

00:01:52.260 --> 00:01:57.810
ask like this echo dollar bang, which means
give me the names of the variables, not the

00:01:57.810 --> 00:02:06.020
value and let us say HI followed by star which
means that all those starts with the HI will

00:02:06.020 --> 00:02:10.630
then be listed, you see that the home is not
listed, because it is HO.

00:02:10.630 --> 00:02:14.880
So, this is a very nice way because if you
want to inspect what are the variables that

00:02:14.880 --> 00:02:16.579
you could actually check it out.

00:02:16.579 --> 00:02:21.560
Now, let us inspect some more features that
are available.

00:02:21.560 --> 00:02:29.780
So, mydate is a string in a variable called
mydate, I would like to store the output from

00:02:29.780 --> 00:02:35.599
the command date and you see that mydate is
now storing a particular string.

00:02:35.599 --> 00:02:41.260
So, I do not want to type such a long string,
so I want to use this shortcut to actually

00:02:41.260 --> 00:02:43.010
also illustrate certain features.

00:02:43.010 --> 00:02:53.959
Now, let us say I want to count how many characters
are there in this particular string.

00:02:53.959 --> 00:02:59.819
So, you see that the hash at the very beginning
is indicating that it should not print the

00:02:59.819 --> 00:03:04.510
value of the particular variable, but the
length of the particular variable.

00:03:04.510 --> 00:03:09.970
So, the length happens to be 38 characters,
so this is 38 characters, you could count

00:03:09.970 --> 00:03:10.970
it off.

00:03:10.970 --> 00:03:16.340
So, as you can see, the braces are actually
very powerful, because the very first character

00:03:16.340 --> 00:03:18.060
tells you what to do with that.

00:03:18.060 --> 00:03:25.690
So, the first character is bang then it actually
asks for the names of the variables if it

00:03:25.690 --> 00:03:29.890
is hash, then it is asking for the length
of the value of the particular variable.

00:03:29.890 --> 00:03:33.209
Now, let us say if the variable is not set,
what would come out.

00:03:33.209 --> 00:03:42.209
So, let us see myvar something is set, so
unset myvar, now, myvar is not set, so if

00:03:42.209 --> 00:03:48.390
I now ask for the length of that particular
variable, and now you see that it says 0,

00:03:48.390 --> 00:03:53.900
because it is not existing, so it has 0 length.

00:03:53.900 --> 00:04:01.209
Now, the colon within the braces is also very
powerful as we have seen earlier, where we

00:04:01.209 --> 00:04:08.540
can take action to display something that
is useful to give us a default value, whether

00:04:08.540 --> 00:04:09.989
the variable is present or absent.

00:04:09.989 --> 00:04:12.830
There are two different ways to go about that.

00:04:12.830 --> 00:04:16.060
Now, we will see some more uses of that particular
colon.

00:04:16.060 --> 00:04:22.970
Now, I would like to illustrate how to extract
a part of a string from the value of a particular

00:04:22.970 --> 00:04:23.970
variable.

00:04:23.970 --> 00:04:34.940
So, for that, we take the mydate as the variable
and look at the value of the variable and

00:04:34.940 --> 00:04:39.520
we like to extract let us say the characters
in a particular range.

00:04:39.520 --> 00:04:46.030
So, you could do that in this fashion, so
from let us say sixth character onwards, I

00:04:46.030 --> 00:04:51.430
would like to start and go up to it let us
say 16, so ten characters I would like to

00:04:51.430 --> 00:04:59.300
display after that, and you see that it is
done here, so after 6 characters, it starts

00:04:59.300 --> 00:05:02.020
to basically take up to 10.

00:05:02.020 --> 00:05:07.669
Now, this is illustrated quite nicely if you
have a string in which you can actually count

00:05:07.669 --> 00:05:08.800
better.

00:05:08.800 --> 00:05:22.339
So, let us do that here, so myvar is equal
to and let us say abcdefgh12345678, so now

00:05:22.339 --> 00:05:25.210
you will be able to relate to it quite easily.

00:05:25.210 --> 00:05:39.000
So, echo dollar myvar and colon and now let
us say I put three colon 3 now, you see that

00:05:39.000 --> 00:05:45.060
the first three are skipped following that
the three characters are being displayed.

00:05:45.060 --> 00:05:49.370
Now, I would make this as four and you see
there are four characters that are displayed.

00:05:49.370 --> 00:05:56.700
So, which means that this part is to indicate
what is the offset and this part is to indicate

00:05:56.700 --> 00:06:00.030
how many characters have to be displayed from
the offset.

00:06:00.030 --> 00:06:05.860
Now, you could also have the offset negative
that is offset from the right-hand side.

00:06:05.860 --> 00:06:11.430
However, you know that minus is used for a
specific purpose already it is used to inspect

00:06:11.430 --> 00:06:13.620
whether the variable was present or not.

00:06:13.620 --> 00:06:18.709
So, a minus sign is to be always preceded
with a blank to indicate not to be confused

00:06:18.709 --> 00:06:19.820
with the other operation.

00:06:19.820 --> 00:06:29.740
So, let us do that here minus 3 colon 3, so
now you see that it is actually coming from

00:06:29.740 --> 00:06:33.970
the right-hand side, so it has offset the
characters by three from the right-hand side

00:06:33.970 --> 00:06:35.700
and printed three of them.

00:06:35.700 --> 00:06:39.800
Now, if I print only two of them, you will
see that only 6 and 7 are displayed 8 is not

00:06:39.800 --> 00:06:40.800
displayed.

00:06:40.800 --> 00:06:46.229
Now, if I happen to ask for more characters
than they are in the string, then it would

00:06:46.229 --> 00:06:48.979
not complain, it would print the how many
are available.

00:06:48.979 --> 00:06:54.130
So, you could also have them as let us say
8 or 9 or something, does not matter, only

00:06:54.130 --> 00:06:58.490
three are available after the offset and therefore
those manually are displayed.

00:06:58.490 --> 00:07:03.630
So, you can see that if you have a string,
you can actually print portions of the string

00:07:03.630 --> 00:07:08.820
either from the left or from the right by
taking an offset and also indicating the number

00:07:08.820 --> 00:07:10.440
of characters after the offset.

00:07:10.440 --> 00:07:20.080
So, if I want to extract from the date command
only the day then what do we do, echo dollar

00:07:20.080 --> 00:07:30.490
mydate colon and we would have no offset and
the six characters and you see that the day

00:07:30.490 --> 00:07:33.140
of the week has been displayed.

00:07:33.140 --> 00:07:39.180
So, this is a very neat way by which you can
extract portions of the strings from the value

00:07:39.180 --> 00:07:43.370
of a variable which is already coming from
the output of the command.

00:07:43.370 --> 00:07:47.450
Let us say we would like to extract only the
date from the date command.

00:07:47.450 --> 00:07:52.339
So, it can be done in two ways, so I would
like to only extract this part, let us say

00:07:52.339 --> 00:07:54.930
only that part can be done in two ways.

00:07:54.930 --> 00:08:00.240
So, first, I would illustrate that by using
the date command itself, so look at the manpage

00:08:00.240 --> 00:08:06.720
for date command and you can see that certain
fields can be displayed, so you can see that

00:08:06.720 --> 00:08:15.279
the percentd can be used for displaying the
date of the month, then percent B for the

00:08:15.279 --> 00:08:24.450
full month name and the percent capital Y
for the year, in four digits.

00:08:24.450 --> 00:08:33.110
So, we could do this by the date command,
so date plus and then the format so percent

00:08:33.110 --> 00:08:38.750
d and then a blank space percent capital B
then blank space percent capital Y.

00:08:38.750 --> 00:08:44.520
So, you can see that we have printed the date
by looking at only particular set of fields.

00:08:44.520 --> 00:08:49.020
Now, we could also extract the fields from
the output which is already available for

00:08:49.020 --> 00:08:53.360
whatever reason, if you want to do that, you
could also do it in this manner mydate is

00:08:53.360 --> 00:09:02.940
equal to, so now I have stored the string
within the variable mydate and echo mydate

00:09:02.940 --> 00:09:12.500
colon, then I would have 6 colon 16 and you
see that output is same, so which means that

00:09:12.500 --> 00:09:20.450
you could also cut portions of your string
and print them by using the manipulation of

00:09:20.450 --> 00:09:24.440
the value of a variable by using the colon.

00:09:24.440 --> 00:09:29.200
So, what comes after the colon the first number
is the offset the second number is the length

00:09:29.200 --> 00:09:31.090
of the string after the offset.

00:09:31.090 --> 00:09:36.490
And that gives you basically the same output
as what we have achieved by using a particular

00:09:36.490 --> 00:09:38.180
command option for the date command.

00:09:38.180 --> 00:09:43.280
So, sometimes the options do not have the
possibilities for the manipulation that we

00:09:43.280 --> 00:09:50.350
want and therefore learning other ways of
manipulating the string is also useful.

00:09:50.350 --> 00:09:55.710
Now, I would like to illustrate the concept
of extracting patterns out of a string.

00:09:55.710 --> 00:10:01.700
We will be learning about the regular expressions
and the grip shortly but we can already get

00:10:01.700 --> 00:10:07.110
introduced to that concept by trying out some
patterns, very simple patterns, which are

00:10:07.110 --> 00:10:10.990
very useful to inspect the file extensions.

00:10:10.990 --> 00:10:20.190
So, I would have let us say myvar as file
name dot txt dot jpg.

00:10:20.190 --> 00:10:25.480
So, it is a string which happens to have two
extensions for whatever reason.

00:10:25.480 --> 00:10:32.560
So, that is a variable myvar in which the
particular string with the two extensions

00:10:32.560 --> 00:10:33.580
are there.

00:10:33.580 --> 00:10:40.020
Now, I would like to extract only the last
extension by a particular pattern.

00:10:40.020 --> 00:10:41.720
So, what is the pattern?

00:10:41.720 --> 00:10:49.690
The pattern is it is following after the dot,
so the dot is used as a placeholder and then

00:10:49.690 --> 00:10:55.880
we can use star for unknown number of characters
to be matched and let us see what we can do

00:10:55.880 --> 00:10:57.200
with respect to the pattern matching.

00:10:57.200 --> 00:11:02.490
So, there are two ways of pattern matching,
whether we would like to the match pattern

00:11:02.490 --> 00:11:10.050
to be displayed or the matched pattern to
be hidden, so both are available.

00:11:10.050 --> 00:11:15.720
So, here we have written in a particular manner,
you can see that there is a hash which is

00:11:15.720 --> 00:11:20.620
coming after the variable name, we have already
seen hash coming up, so if it came in front

00:11:20.620 --> 00:11:25.300
of the variable, that is number of characters
are accounted for particular variable, so

00:11:25.300 --> 00:11:29.000
it is coming after the name of the variable
and then there is a pattern, the pattern is

00:11:29.000 --> 00:11:34.760
star dot, so you see what happens when you
try to echo and you see that a pattern that

00:11:34.760 --> 00:11:37.240
is matching star dot is displayed.

00:11:37.240 --> 00:11:44.290
Now, if you have one hash it would actually
see what is the minimum that you can match

00:11:44.290 --> 00:11:48.920
with the star, so when the file name is matched
and then after that just stopped, but technically

00:11:48.920 --> 00:11:54.770
file name dot txt itself can be matched as
a star dot because there is one more dot available,

00:11:54.770 --> 00:12:03.280
so that can be achieved by asking it to maximize
the amount of matching by using double hashes.

00:12:03.280 --> 00:12:10.550
So, this idea of double hash or double percentage
sign etcetera that we will see are used to

00:12:10.550 --> 00:12:12.960
indicate a minimum and maximum matching.

00:12:12.960 --> 00:12:19.620
So, you see that the extension has come out
now, this extension is not by counting number

00:12:19.620 --> 00:12:26.560
of characters, but by using the pattern where
a dot is used as a separator.

00:12:26.560 --> 00:12:29.620
So, how do we verify, let us do this way.

00:12:29.620 --> 00:12:40.760
So, myvar is equal to let us say myfilename
dot somethingelse dot and then jpeg now, the

00:12:40.760 --> 00:12:42.560
extension is four characters.

00:12:42.560 --> 00:12:47.790
And now, if you see here jpeg is coming out
which means that we are not going by the number

00:12:47.790 --> 00:12:53.290
of characters that are being matched, but
by a pattern and the pattern is star dot,

00:12:53.290 --> 00:12:57.840
which means that after an unknown number of
characters so there should be a dot and that

00:12:57.840 --> 00:13:03.860
should be matched as largely as possible by
using the double hash symbols.

00:13:03.860 --> 00:13:10.380
So, the entire myfilename dot somethingelse
dot will be matched for the pattern that is

00:13:10.380 --> 00:13:16.000
being displayed here and then the remaining
part is actually displayed as the output so

00:13:16.000 --> 00:13:17.990
jpeg is coming out as an output.

00:13:17.990 --> 00:13:23.470
So, this is quite useful to find out what
is the extension or that particular file name

00:13:23.470 --> 00:13:27.870
that is coming into the script by ignoring
whatever is in front of the dot symbol.

00:13:27.870 --> 00:13:34.940
Now, the opposite of it is to display what
has not been matched, so that is used done

00:13:34.940 --> 00:13:45.570
using the percentage symbol, percentage and
now, I would like to match what is in front

00:13:45.570 --> 00:13:54.870
and therefore, I would use the dot star as
a way to match, so dot star and you see that

00:13:54.870 --> 00:14:01.870
whatever is in front of the dot has now been
matched and it is matching as minimal as possible,

00:14:01.870 --> 00:14:04.180
because only this part is been removed.

00:14:04.180 --> 00:14:08.280
Now, I would like to remove this part alone
fully so that only the stem of the file name

00:14:08.280 --> 00:14:15.210
is shown, so for that as I mentioned earlier
double usage of that particular trigger can

00:14:15.210 --> 00:14:22.700
be useful, so we use the symbol twice here,
then the maximum possible matching will be

00:14:22.700 --> 00:14:27.671
done and now, you can see the only the stem
is shown myfilename, so dot somethingelse

00:14:27.671 --> 00:14:33.970
dot jpg has been matched with the pattern
that we have put as dot star and then the

00:14:33.970 --> 00:14:35.340
remaining part is now displayed.

00:14:35.340 --> 00:14:41.400
So, now, you see that the use of hash as well
as a percentage sign, percentage sign is showing

00:14:41.400 --> 00:14:48.070
you what is in front of the dot and then the
hash is showing you what is after the dot

00:14:48.070 --> 00:14:50.690
by the way we have given the patterns.

00:14:50.690 --> 00:14:55.420
So, now let us say I would like to make the
name of this particular variable to be such

00:14:55.420 --> 00:14:58.110
that it is only the stem followed by the extension.

00:14:58.110 --> 00:15:06.210
So, we could do that in this manner echo dollar
myvar percentage percentage dot star that

00:15:06.210 --> 00:15:17.230
will give me the stem and then dollar myvar
hash hash star dot that will give me only

00:15:17.230 --> 00:15:18.230
the extension.

00:15:18.230 --> 00:15:23.279
And you see that we have got it as filename
jpg, and now, I would like to have a dot in

00:15:23.279 --> 00:15:28.620
between them, so that its like a file name
dot extension and I have got that now modified.

00:15:28.620 --> 00:15:33.550
So, you can see that we have been able to
manipulate a string myfilename dot somethingelse

00:15:33.550 --> 00:15:39.420
dot jpg as the stem dot the extension alone,
without even worrying about how much of the

00:15:39.420 --> 00:15:44.790
text is in between the two dots, and we have
just knocked it off and created this of course,

00:15:44.790 --> 00:15:49.040
we can also use it to give the extension in
a different manner also.

00:15:49.040 --> 00:15:56.610
So, for example, you could actually make it
like this and so depending upon our requirements

00:15:56.610 --> 00:16:01.370
of the script, these kinds of manipulations
can be quite useful and these are also very

00:16:01.370 --> 00:16:04.279
fast because these are inbuilt features for
the bash.

00:16:04.279 --> 00:16:11.610
Now, I will illustrate how to do a pattern
matching, which is to also do the replacement.

00:16:11.610 --> 00:16:17.110
So, earlier what we have done is to display
what has been matched or to display what has

00:16:17.110 --> 00:16:21.460
not been matched by using the symbol hash
and percentage.

00:16:21.460 --> 00:16:25.760
Now, we can also do a replacement of whatever
has been matched.

00:16:25.760 --> 00:16:29.910
So, here we would actually illustrate that
and there are four different ways of doing

00:16:29.910 --> 00:16:31.560
that.

00:16:31.560 --> 00:16:41.089
So, what I would do is echo myvar, now pattern
matching in most of the Linux environment

00:16:41.089 --> 00:16:48.279
always goes with a pair of forward slashes,
so that is something that we will use in GREP

00:16:48.279 --> 00:16:54.270
when we learn about regular expressions later
on, but already we can start trying it out.

00:16:54.270 --> 00:17:00.670
So, if you use it once, it will actually replace
it once, so what I would like to do is whenever

00:17:00.670 --> 00:17:07.520
I have got small e I would like to make it
as a capital E let us say, small e I like

00:17:07.520 --> 00:17:08.520
to make it as capital E.

00:17:08.520 --> 00:17:17.250
So, you see that the display is done for the
whole variable and the first e is been replaced

00:17:17.250 --> 00:17:24.730
with the capital E but the second e has not
been done and the third one also has not been

00:17:24.730 --> 00:17:31.380
touched, so which means that when you use
this forward slash once it replaces only once.

00:17:31.380 --> 00:17:38.350
Now, if you would like it to replace as many
times as it occurs, so you will put twice

00:17:38.350 --> 00:17:44.050
of that and you see that every time the small
e has occurred it has been replaced with capital

00:17:44.050 --> 00:17:49.500
E, so you could see that everywhere it has
been done and this difference is coming because

00:17:49.500 --> 00:17:55.890
you have used this particular pattern matching
trigger twice, so normally the same convention

00:17:55.890 --> 00:18:00.540
is applicable, so if we have used the trigger
once it is done once and if you have done

00:18:00.540 --> 00:18:05.000
it twice it means it will done it will do
the matching the maximum number of times that

00:18:05.000 --> 00:18:06.000
is possible.

00:18:06.000 --> 00:18:11.710
So, it has been observed for all the implementations
of string manipulations as we have seen till

00:18:11.710 --> 00:18:12.710
now.

00:18:12.710 --> 00:18:16.090
Sometimes you may want to check whether this
pattern is matching should be done in the

00:18:16.090 --> 00:18:18.730
beginning of the string or at the end of the
string.

00:18:18.730 --> 00:18:24.030
So, let us do that out, let us just try that
out.

00:18:24.030 --> 00:18:29.600
So, let us say if the file name starts with
the capital M then you should change it with

00:18:29.600 --> 00:18:35.420
small m, so we could try that out.

00:18:35.420 --> 00:18:49.540
Here the pattern is actually preceded with
a hash and let us say a small m, capital M,

00:18:49.540 --> 00:18:57.580
so you see that the beginning M has been changed
to small m and nothing else has occurred.

00:18:57.580 --> 00:19:08.410
Now, we could also check this out with respect
to E. So, you see that the capital E that

00:19:08.410 --> 00:19:13.550
is there, is the first capital E within this
particular string, but it has not been changed

00:19:13.550 --> 00:19:18.860
because the hash in front of capital E indicates
that you should change it only if it occurs

00:19:18.860 --> 00:19:23.650
in the beginning of the string and therefore,
this will not affect, so what is the difference

00:19:23.650 --> 00:19:28.710
if I were to actually not have the hash then
the first occurrence of capital E will be

00:19:28.710 --> 00:19:34.210
changed with the m and you see that here it
has been done and this is not what we intended.

00:19:34.210 --> 00:19:38.420
So, something like that you could actually
trigger whether it has to be matched in the

00:19:38.420 --> 00:19:41.100
beginning or somewhere in the middle.

00:19:41.100 --> 00:19:50.309
So, I will correct it with e so that it actually
also makes some sense in English.

00:19:50.309 --> 00:19:56.650
Now, you could also ask the same thing to
be done at the end of the string, so echo

00:19:56.650 --> 00:20:03.210
dollar, myvar and the past pattern I wanted
to the end so, I would put it as a percentage

00:20:03.210 --> 00:20:08.179
symbol and if the end of the string happens
to be small g I would like to make it with

00:20:08.179 --> 00:20:09.179
a capital G.

00:20:09.179 --> 00:20:15.800
Now, you see that only the end of the string
has been modified to capital G, but there

00:20:15.800 --> 00:20:20.160
is one more g here in the middle that has
not been touched.

00:20:20.160 --> 00:20:25.809
Now, what will happen if you did not have
the percentage, you see that whatever is in

00:20:25.809 --> 00:20:30.910
the middle has been encountered first while
parsing, so parsing is generally done from

00:20:30.910 --> 00:20:34.490
the beginning of the string and therefore,
this G is the first one, so that has been

00:20:34.490 --> 00:20:38.510
made into capital and the last g of the string
has not been touched.

00:20:38.510 --> 00:20:46.130
So, you see the difference between this usage
and this usage, so if you have preceded the

00:20:46.130 --> 00:20:50.560
pattern to be matched with a percentage sign
symbol, then it will be matching with the

00:20:50.560 --> 00:20:54.470
end of the string, but if you did not have
it, it will be done at the first occurrence

00:20:54.470 --> 00:20:55.470
of the string.

00:20:55.470 --> 00:20:59.610
There are four different ways of matching
that is basically once or many times or at

00:20:59.610 --> 00:21:01.770
the beginning of the string or at the end
of the string.

00:21:01.770 --> 00:21:07.570
Now, it’s up to you to imagine how you can
combine these to ensure that you are basically

00:21:07.570 --> 00:21:11.100
are able to modify the names as you like.

00:21:11.100 --> 00:21:18.559
So, in this case, for example, I want to just
run a script which changes the string jpeg

00:21:18.559 --> 00:21:23.390
to jpg, but I want it only if it is in the
end of the string so that it is only affecting

00:21:23.390 --> 00:21:26.830
the file extension and not the name of the
file.

00:21:26.830 --> 00:21:35.040
So, what I would do here is as follows, jpg
and I would like it to be only in the end,

00:21:35.040 --> 00:21:40.049
so I put a percentage symbol there and you
see that the file extension alone has been

00:21:40.049 --> 00:21:43.220
tampered with and everything else is present.

00:21:43.220 --> 00:21:48.580
So, how do we verify that, let us say I will
change the name of the variable to be like

00:21:48.580 --> 00:21:58.690
this myvar is equal to and I say myjpegfile
dot something dot jpeg.

00:21:58.690 --> 00:22:08.970
Now, you see that I have got two occurrences
of jpeg as a string and you see here, the

00:22:08.970 --> 00:22:13.940
first occurrence of jpeg is not touched, the
last occurrence only has been touched and

00:22:13.940 --> 00:22:18.060
that has been changed to jpg because of the
percentage symbol.

00:22:18.060 --> 00:22:25.120
Now, I would try what happens if I did not
do that, so you can see that here the first

00:22:25.120 --> 00:22:30.230
occurrence of jpeg has been changed to jpg,
but the last occurrence has been ignored.

00:22:30.230 --> 00:22:35.049
Now, I want to change everywhere for example,
I would obviously have the possibility to

00:22:35.049 --> 00:22:39.340
use a forward slash twice and it will do everywhere
that is possible.

00:22:39.340 --> 00:22:46.299
So, you can see jpeg is occurring twice and
in the beginning of the string as well as

00:22:46.299 --> 00:22:50.820
at the end of the string, and both those portions
have been changed to jpg.

00:22:50.820 --> 00:22:59.870
So, you can see that you can actually match
portions of the string and replace them or

00:22:59.870 --> 00:23:01.940
extract or delete them.

00:23:01.940 --> 00:23:06.780
So, you have all these possibilities, now,
by a combination of all these you can actually

00:23:06.780 --> 00:23:12.850
go on to try what you like with respect to
those variables, how do we actually store

00:23:12.850 --> 00:23:18.270
the output of one operation in another variable,
so that we can then go on to do further operations,

00:23:18.270 --> 00:23:20.420
we already have the back quote for that.

00:23:20.420 --> 00:23:29.140
So, we will do like this myvar1 is equal to
back quote eco, then we can actually have

00:23:29.140 --> 00:23:43.170
this myvar, now echo myvar1 and you see that
now the myvar1 is contained in the output

00:23:43.170 --> 00:23:44.850
of whatever manipulation we have done.

00:23:44.850 --> 00:23:51.740
Now, we can actually illustrate this by extracting
the day out of the date string, so mydate

00:23:51.740 --> 00:23:59.510
is equal to back quote date, so echo mydate
will contain the string, now I would like

00:23:59.510 --> 00:24:11.510
to just manipulate what is the first word
Sunday, so mydate, then I have got hash star

00:24:11.510 --> 00:24:16.970
day so that would match the Sunday and there
is nothing else that is matching with the

00:24:16.970 --> 00:24:17.970
day there.

00:24:17.970 --> 00:24:21.460
And you see that the Sunday alone has been
knocked off and rest of it is displayed.

00:24:21.460 --> 00:24:27.860
So, you could actually try these kinds of
manipulations on strings, which are outputs

00:24:27.860 --> 00:24:34.679
of other commands, so that you can achieve
the kind of pattern that you are looking for.

00:24:34.679 --> 00:24:39.750
Now, let us say we would like to also do some
manipulations with respect to the case change,

00:24:39.750 --> 00:24:42.900
that is the uppercase to lowercase and vice
versa.

00:24:42.900 --> 00:24:47.600
So, those are also available and they are
very powerful because we will see that the

00:24:47.600 --> 00:24:52.470
speed of those operations is much faster than
if you were to do by a separate program.

00:24:52.470 --> 00:25:01.160
So, let us do that here mydate is with the
combination of capital letters as well as

00:25:01.160 --> 00:25:02.160
small letters.

00:25:02.160 --> 00:25:10.270
So, I would now do a manipulation, so with
a comma so I just use a comma there and you

00:25:10.270 --> 00:25:15.150
see that only the first character has been
made to a small letter the January J is still

00:25:15.150 --> 00:25:21.260
a capital letter and if I want the entire
string to be in a small letter, so though

00:25:21.260 --> 00:25:27.910
I put two commas and you see that the January
also has a small j, ist also has a smaller

00:25:27.910 --> 00:25:33.730
ist, AM also is changed to small am so, comma
or two commas basically indicate whether you

00:25:33.730 --> 00:25:40.450
would like to have the first character to
be changed to a lower case or all the characters

00:25:40.450 --> 00:25:43.720
to be changed to the lowercase.

00:25:43.720 --> 00:25:48.970
The same thing can be applied in a reverse
manner for uppercase where instead of comma

00:25:48.970 --> 00:26:01.480
you would actually have a hat, hat now this
is not going to be very useful, because Sunday

00:26:01.480 --> 00:26:05.080
for the original string already has a capital
letter, so for that, I would use some other

00:26:05.080 --> 00:26:12.280
variable, so myvar is equal to hello and echo
myvar hat.

00:26:12.280 --> 00:26:19.370
So, you see that the H is now capital, so
original variable it does not have a capital

00:26:19.370 --> 00:26:22.370
H in the beginning, now it is capital H if
I use hat.

00:26:22.370 --> 00:26:24.860
Now, if I use double hat what happens?

00:26:24.860 --> 00:26:31.150
So, by the same connotation, all the letters
will be changed to uppercase and you can see

00:26:31.150 --> 00:26:32.150
that has been done.

00:26:32.150 --> 00:26:40.250
So, this can be also applicable for the string
that we have just now tried mydate double

00:26:40.250 --> 00:26:44.810
hat and you see the entire date string has
been converted to uppercase.

00:26:44.810 --> 00:26:51.380
So, this is quite useful in some pattern matching
in situations where you need to work with

00:26:51.380 --> 00:26:56.580
full capital letters or small letters as the
convention for that particular file format

00:26:56.580 --> 00:27:02.670
may require and you can do those conversions
within no time just by adding these trailing

00:27:02.670 --> 00:27:05.370
characters after the variable name within
the braces.

00:27:05.370 --> 00:27:09.850
So, you can see that this construction of
a variable with the braces is very powerful,

00:27:09.850 --> 00:27:14.120
because by having things within the braces,
there are commands that can actually operate

00:27:14.120 --> 00:27:16.520
on the value of that particular variable.

00:27:16.520 --> 00:27:24.650
Now, you can look at the manpage for date
and you see that there is actually no easy

00:27:24.650 --> 00:27:29.730
manner by which I can actually have the day
of the week in a capital letter.

00:27:29.730 --> 00:27:35.610
So, you can see that capital A is for the
week day, but it is such that the first character

00:27:35.610 --> 00:27:37.490
is capital rest of it is small.

00:27:37.490 --> 00:27:43.090
So, if I want Sunday to be displayed as full
caps, then it is not readily available and

00:27:43.090 --> 00:27:50.650
these are the kinds of situations where here
you have got ability to do it by just extracting

00:27:50.650 --> 00:27:54.240
the string and then manipulating the string.

00:27:54.240 --> 00:27:59.640
You have seen that we have been assigning
values to variables of different types and

00:27:59.640 --> 00:28:04.750
we are also changing the type of value for
the same variable.

00:28:04.750 --> 00:28:10.610
So, sometimes it is alphanumeric, sometimes
it says a number and we were also able to

00:28:10.610 --> 00:28:17.500
change the case of the string uppercase characters
or lowercase characters as we would like to

00:28:17.500 --> 00:28:24.780
have them as, so is it possible to have the
restrictions on the variable so that the values

00:28:24.780 --> 00:28:30.830
can be either only uppercase characters or
only lowercase characters, only a string type

00:28:30.830 --> 00:28:37.440
of a value or only numerical value, such a
restriction is possible on the variables using

00:28:37.440 --> 00:28:43.810
the declare command and let us explore that
now to see how to restrict the values that

00:28:43.810 --> 00:28:46.080
can be assigned to a particular shell variable.

00:28:46.080 --> 00:28:52.140
Now, let us look at the help for the declare
command and you see that it is not there,

00:28:52.140 --> 00:28:55.640
so which means that it is not a manpage.

00:28:55.640 --> 00:29:01.150
So, it may be a shell bulletin and therefore
now you see that it is available.

00:29:01.150 --> 00:29:12.150
So, it is actually coming from the shell,
so what 

00:29:12.150 --> 00:29:14.600
type of a command is that?

00:29:14.600 --> 00:29:23.100
So, it says it is a shell bulletin, so help
declare what are the various features that

00:29:23.100 --> 00:29:24.100
are available.

00:29:24.100 --> 00:29:30.691
Now, you can see that there are some options
that are there, which go in front of the name

00:29:30.691 --> 00:29:31.691
of the variable.

00:29:31.691 --> 00:29:35.750
So, here for example, minus a says that the
particular variable is actually an indexed

00:29:35.750 --> 00:29:42.630
array, or it can be an associative array,
or it can be an integer, uppercase characters,

00:29:42.630 --> 00:29:47.030
or it can have lowercase characters and so
on.

00:29:47.030 --> 00:29:52.230
And you can actually use the plus sign to
unset that particular restriction and minus

00:29:52.230 --> 00:29:53.679
sign to actually set it.

00:29:53.679 --> 00:29:58.040
That is a little counterintuitive, but normally
all options come with a minus sign, so therefore,

00:29:58.040 --> 00:29:59.460
it is used in that sense.

00:29:59.460 --> 00:30:07.780
So, let us go and explore that declare and
then I would like to insist that numbers only

00:30:07.780 --> 00:30:14.860
should be stored in a variable called mynum,
so mynum should only have integers.

00:30:14.860 --> 00:30:27.650
So, mynum is equal to 10 echo mynum and you
will see that the variable is storing it correctly.

00:30:27.650 --> 00:30:35.000
Now, I try to store a string in that and now
what happens is of course, it does not comply

00:30:35.000 --> 00:30:41.289
upfront, but you see that it has stored 0.

00:30:41.289 --> 00:30:48.100
So, you can see that when you try to store
a string in a variable which is designated

00:30:48.100 --> 00:30:53.850
only to store integers then things will go
wrong and you normally get 0 if you try to

00:30:53.850 --> 00:30:55.370
assign it.

00:30:55.370 --> 00:31:01.290
So, now, let us do the same thing with the
other variables with other restrictions, so

00:31:01.290 --> 00:31:05.660
the minus i restriction is for integers.

00:31:05.660 --> 00:31:14.500
So, let us say minus l for lowercase characters,
so I will say myvar, so myvar is equal to

00:31:14.500 --> 00:31:22.080
hello echo myvar and you see that it is able
to reproduce quite well.

00:31:22.080 --> 00:31:26.220
Now, I would like to store something else
in that.

00:31:26.220 --> 00:31:37.870
So, capital HELLO and you see that the capital
H has been translated to small H and the string

00:31:37.870 --> 00:31:39.630
has not really changed its character.

00:31:39.630 --> 00:31:45.280
So, the same string is available, so it is
not as problematic as in integers where we

00:31:45.280 --> 00:31:50.370
actually lost that particular value and we
got a 0 as the value of the variable.

00:31:50.370 --> 00:31:55.760
So, here that is not the problem only the
case has been adjusted to fit to what is the

00:31:55.760 --> 00:31:59.280
declared case for the variable and that is
quite fine.

00:31:59.280 --> 00:32:09.770
So, we could actually also see that you could
mix the cases, anywhere the string and that

00:32:09.770 --> 00:32:13.880
would still ensure that the string is only
having lowercase characters, this is very

00:32:13.880 --> 00:32:18.630
convenient where you are expecting for example,
all the characters to be lower cases there

00:32:18.630 --> 00:32:23.809
is no point in trying to search for uppercase
and then replace them etcetera, you just simply

00:32:23.809 --> 00:32:29.140
put the restriction and then assign the values
and the values will be adjusted as per the

00:32:29.140 --> 00:32:32.610
declared case of that particular string variable.

00:32:32.610 --> 00:32:38.910
Now, let us declare the string variable with
the uppercase characters, so for that I would

00:32:38.910 --> 00:32:43.530
actually say myvar is my uppercase variable.

00:32:43.530 --> 00:32:53.039
So, myvar is equal to and here I would type
HELLO echo and it will contain the uppercase

00:32:53.039 --> 00:32:55.490
characters as we have originally assigned.

00:32:55.490 --> 00:33:06.530
Now, if I happen to assign a small case, lower
case 

00:33:06.530 --> 00:33:09.049
and they would automatically get converted
to uppercase.

00:33:09.049 --> 00:33:24.520
So, again, try that out 

00:33:24.520 --> 00:33:29.960
you see that the entire string has been converted
to uppercase because we have made the restriction

00:33:29.960 --> 00:33:32.760
here to be uppercase characters.

00:33:32.760 --> 00:33:38.049
So, these restrictions are quite useful in
doing some translations of the characters

00:33:38.049 --> 00:33:41.280
automatically while the value has been assigned.

00:33:41.280 --> 00:33:45.890
So, we could actually also switch off that
particular attribute.

00:33:45.890 --> 00:33:53.920
So, I can say declare plus u so I am just
switching off the uppercase restriction for

00:33:53.920 --> 00:33:59.740
myvar and then I would assign the string which
is having lowercase characters.

00:33:59.740 --> 00:34:03.530
So, now I have put a plus u which means I
have removed the restriction.

00:34:03.530 --> 00:34:10.389
So, if I echo then I would get the same string
with lower case characters so the restriction

00:34:10.389 --> 00:34:11.520
has now been removed.

00:34:11.520 --> 00:34:16.540
So, the same thing is possible with the other
variables that we have done so declare plus

00:34:16.540 --> 00:34:28.940
l myvar and myvar is equal to, so it is now
accepting uppercase characters because the

00:34:28.940 --> 00:34:32.359
restriction of lowercase has been removed
with a plus l.

00:34:32.359 --> 00:34:38.829
it is a little different because plus l normally
means as if you are adding some attributes,

00:34:38.829 --> 00:34:44.299
but in this case it is actually removing the
attribute of forcing the lower case characters

00:34:44.299 --> 00:34:45.520
for that particular variable.

00:34:45.520 --> 00:34:51.619
Now, there is another attribute which is also
to ensure that you do not change the value

00:34:51.619 --> 00:34:56.409
of that particular variable once it is made
available to the user, that is basically the

00:34:56.409 --> 00:34:57.549
read only attribute.

00:34:57.549 --> 00:35:09.180
So, let us say today is equal to date, so
echo dollar today so the date is fixed.

00:35:09.180 --> 00:35:14.980
Now, I would like to make this particular
variable today as a read only, so I will say

00:35:14.980 --> 00:35:19.480
declare minus r today.

00:35:19.480 --> 00:35:34.059
So, you see here I cannot now change it, so
it prevents me from changing the value of

00:35:34.059 --> 00:35:39.930
the variable today because it is read only
so it does not get changed.

00:35:39.930 --> 00:35:50.109
Now, I can also not change the attribute itself,
even the attribute changing also is not possible

00:35:50.109 --> 00:35:54.420
which means that once you set a particular
variable as read only, then by and large it

00:35:54.420 --> 00:35:58.150
is safe because you cannot change the attribute,
you cannot also change the value.

00:35:58.150 --> 00:36:04.339
So, it is a very nice way by which if you
have a script that is passed on to a user

00:36:04.339 --> 00:36:09.460
and you want to have some variables in the
script to be available to the user but only

00:36:09.460 --> 00:36:14.839
as a read only feature then you can have this
attribute and then pass on and then those

00:36:14.839 --> 00:36:18.729
variables cannot be modified by the user either
intentionally or by mistake.

00:36:18.729 --> 00:36:21.890
Now, let us explore the concept of arrays.

00:36:21.890 --> 00:36:27.710
There are two types of arrays, index arrays
as well as the associate arrays, but is basically

00:36:27.710 --> 00:36:33.759
the regular arrays with an integer as the
index or a string as an index in the case

00:36:33.759 --> 00:36:36.150
of the hashes associate arrays.

00:36:36.150 --> 00:36:45.630
So, this is done by using the declare option,
so we will say declare minus a and then array

00:36:45.630 --> 00:36:47.799
so arr is my array.

00:36:47.799 --> 00:36:53.529
So, now arr happens to be an array and therefore
we can actually start assigning values to

00:36:53.529 --> 00:37:01.410
it so arr and then the array index can be
given in the square brackets, so we would

00:37:01.410 --> 00:37:04.059
give the first index as 0 for example.

00:37:04.059 --> 00:37:08.401
And the equal to sign has to be given just
like any other shell variable, so no space

00:37:08.401 --> 00:37:12.400
between the variable name and the equal to
sign.

00:37:12.400 --> 00:37:14.890
So, those restrictions are applicable.

00:37:14.890 --> 00:37:24.640
So, we will have the first value as Sunday
and array 1 is Monday.

00:37:24.640 --> 00:37:33.140
So, now I would like to check what are the
variables stored in this particular array,

00:37:33.140 --> 00:37:45.140
so we could actually inspect those now, dollar
array and then let us say 0, so it will give

00:37:45.140 --> 00:37:53.849
you the 0th item and the first item available,
now if you happen to give any arbitrary index

00:37:53.849 --> 00:37:58.839
and if it is not there nothing dangerous will
happen, it is just simply going to give you

00:37:58.839 --> 00:38:03.009
a null because such a variable does not exist
and this is true for any other shell variable.

00:38:03.009 --> 00:38:09.020
So, if you ask for any shell variable which
did not exist it does not crib much, it just

00:38:09.020 --> 00:38:11.770
simply give you a null on the screen and moves
on.

00:38:11.770 --> 00:38:17.960
Now, how do I know how many elements are there
in the array?

00:38:17.960 --> 00:38:28.910
Hash array and here in the index position
I just put a symbol at to indicate all the

00:38:28.910 --> 00:38:37.140
possible keys are to be used for that purpose
and now we get a number 2, so that means there

00:38:37.140 --> 00:38:45.029
are two values that are stores in the array
called arr, now what are those also can be

00:38:45.029 --> 00:38:56.170
asked, so without the hash basically the variable
itself it used, so you could then ask for

00:38:56.170 --> 00:38:59.799
what are all those and you see that both the
values are now displayed on the screen.

00:38:59.799 --> 00:39:07.630
You could also ask what are the indices that
are actually used.

00:39:07.630 --> 00:39:16.450
So, we already have come across the exclamation
mark it is basically to inspect the names

00:39:16.450 --> 00:39:21.579
of the variables so in this case being an
array the name is basically the index and

00:39:21.579 --> 00:39:25.780
therefore that will be returned and you see
the indices that are being used are 0 and

00:39:25.780 --> 00:39:26.780
1.

00:39:26.780 --> 00:39:28.890
Now, why is that actually important?

00:39:28.890 --> 00:39:33.180
If you knew the size of the array, is it not
obvious that you could just simply go up to

00:39:33.180 --> 00:39:38.319
the size of the array, so here you have 2
which means that 0, 1 should be the two indices

00:39:38.319 --> 00:39:42.759
that are possible, the answer is no because
you can actually have any other index also

00:39:42.759 --> 00:39:47.660
used without actually filling up intermediate
indices, so I could actually have something

00:39:47.660 --> 00:39:59.190
like this array of 100 is equal to, and I
can make some 

00:39:59.190 --> 00:40:00.499
random string.

00:40:00.499 --> 00:40:10.770
Now, I can ask how many elements are there,
so it says there are three elements, so what

00:40:10.770 --> 00:40:11.770
are the indices?

00:40:11.770 --> 00:40:24.150
It is not 0, 1 and 2 but it is 0, 1 and 100.

00:40:24.150 --> 00:40:28.940
You can see that the indices are 0, 1 and
100, so it very important for us to inspect

00:40:28.940 --> 00:40:33.109
what are the indices because those indices
are not necessarily continuous.

00:40:33.109 --> 00:40:38.380
So, this is one of fundamental difference
between the arrays in shell versus arrays

00:40:38.380 --> 00:40:43.259
in C language or FORTRAN language etcetera
where the indices are all continuous from

00:40:43.259 --> 00:40:45.809
0 to the size of the array.

00:40:45.809 --> 00:40:49.990
Now, let us say you would like to delete a
particular element from the array, so in this

00:40:49.990 --> 00:40:56.329
case I would like to delete the 100th element,
so you could do it with unset, so unset and

00:40:56.329 --> 00:41:06.309
then array 100, so I pass on along with the
index so that the entire thing is interpreted

00:41:06.309 --> 00:41:12.261
as if it is a variable name and that is removed,
so now I can ask how many elements are there,

00:41:12.261 --> 00:41:16.309
there are two elements and what are those
indices, and 0 and 1.

00:41:16.309 --> 00:41:23.329
So, the 100th elements has been removed by
using the unset command and the index which

00:41:23.329 --> 00:41:28.720
we would like to remove is indicated with
in the square brackets as if the entire thing

00:41:28.720 --> 00:41:31.849
is a variable name.

00:41:31.849 --> 00:41:38.630
Now, can I append something to the array that
is used in the same syntax as in C language,

00:41:38.630 --> 00:41:46.489
so you could have array plus is equal to and
values of the array are generally given in

00:41:46.489 --> 00:41:54.680
parenthesis so you could have something like
this, now you could then ask how many elements

00:41:54.680 --> 00:42:00.839
are there in the array, there are three elements
and what are those indices, 0 and 1 and 2

00:42:00.839 --> 00:42:05.959
and what are those variables, so you could
say Sunday, Monday, Tuesday.

00:42:05.959 --> 00:42:15.950
So, you could see that you can append a value
to array, you can insert a particular value

00:42:15.950 --> 00:42:21.009
in the array with any arbitrary index, you
could also remove it from the particular array,

00:42:21.009 --> 00:42:25.170
you could inspect what are all the indices
that are being used and you can also inspect

00:42:25.170 --> 00:42:31.069
what are the values that are used in an array,
so you can see that the array concept in the

00:42:31.069 --> 00:42:33.219
shell environment is quite rich.

00:42:33.219 --> 00:42:37.229
So, you can also populate an array in one
go, so you could do that in this manner for

00:42:37.229 --> 00:42:57.150
example, so array is equal to and in brackets
you could actually give the values, and now

00:42:57.150 --> 00:43:08.789
you could ask what are those variables, so
you have got all those variables and what

00:43:08.789 --> 00:43:13.589
are all the indices, so indices go in the
sequence.

00:43:13.589 --> 00:43:21.259
So, if you have populated the array in one
go then the indices are sequential because

00:43:21.259 --> 00:43:25.369
that is the most obvious thing to do in such
a situation but there is no restriction for

00:43:25.369 --> 00:43:28.630
you to stick to it, you can actually insert
anything at any position.

00:43:28.630 --> 00:43:33.410
There are also some situation where you would
like to have the index of an array not as

00:43:33.410 --> 00:43:41.130
a integer but as a string, so like for example,
a roll number which is string can be then

00:43:41.130 --> 00:43:43.609
mapped with the name of the person for example.

00:43:43.609 --> 00:43:51.619
So, you could also declare them as associate
arrays or associative arrays or hashes.

00:43:51.619 --> 00:43:59.709
So, let us have that as a hash, declare minus
a hash, so hash is now a name of variable

00:43:59.709 --> 00:44:08.670
and it will contain sequence of values which
can be indexed using strings and not necessarily

00:44:08.670 --> 00:44:13.099
using only integers, integers are also possible.

00:44:13.099 --> 00:44:25.530
So, let us say 0 is equal to and the first
value I would let us give a name Amal hash

00:44:25.530 --> 00:44:32.309
1 is equal to Bimal.

00:44:32.309 --> 00:44:41.710
Now, comes the idea, this is like an array
but it’s a associative array so you can

00:44:41.710 --> 00:44:46.089
use indices which are not necessarily integers
but also strings, so I will use a string which

00:44:46.089 --> 00:45:01.729
looks like a roll number, so that is like
a roll number typically and now you can see

00:45:01.729 --> 00:45:15.539
that it is accepting that and now look at
the keys that are used, so this bang or exclamation

00:45:15.539 --> 00:45:21.180
mark tells you to inspect the name of the
arrays and in this case it say array and therefore

00:45:21.180 --> 00:45:26.269
the indices are then extracted, the at symbols
tells you to run through the entire array,

00:45:26.269 --> 00:45:32.880
so now you can see that the three indices
that are used are 1, 0 and mm12b001, so you

00:45:32.880 --> 00:45:37.910
could actually mix indices to be just strings
or numbers.

00:45:37.910 --> 00:45:49.650
So, I would actually have the strings to be
anything else new student, and you could now

00:45:49.650 --> 00:45:57.209
see that there are four indices of course,
the space may appear as if it is 5, but you

00:45:57.209 --> 00:46:07.780
can actually count, so let us do the counting
here, so you see there are only four of them,

00:46:07.780 --> 00:46:16.680
and each of them we can then go on to inspect
the value and here you should give the key,

00:46:16.680 --> 00:46:24.589
so you could give the key as let us say and
it will give you the value.

00:46:24.589 --> 00:46:29.819
So, you can see that they keys need not be
simple strings, they can be complicated strings

00:46:29.819 --> 00:46:39.569
with spaces in between, it could also be numbers
and you are now free to store a hash of set

00:46:39.569 --> 00:46:43.539
of values that you would like to keep for
your work.

00:46:43.539 --> 00:46:50.180
So, you could actually have this as a additional
feature to write scripts which can be used

00:46:50.180 --> 00:46:58.500
to manipulate the output of a command the
way you would like to have for your scripting

00:46:58.500 --> 00:46:59.500
usage.

00:46:59.500 --> 00:47:14.499
So, when I type ls I have got the list of
the files there, declare minus a myfile.

00:47:14.499 --> 00:47:30.680
So, here you have got 11 and you could inspect
what are all those indices, so it goes from

00:47:30.680 --> 00:47:42.640
0 to 10 and what are those you could also
inspect them, so bin and then desktop, then

00:47:42.640 --> 00:47:46.529
documents and downloads and so on.

00:47:46.529 --> 00:47:53.470
So, you could see that there are 11 folders
in the directory that I have with the ls command,

00:47:53.470 --> 00:47:58.869
I am getting 11 entries, and those 11 entries
are now indexed from 0 to 10 in the array

00:47:58.869 --> 00:48:03.589
called myfiles and I can inspect each of them
one after another in this manner, so if I

00:48:03.589 --> 00:48:07.940
have a script that runs through each of this
directory to perform some action, it is now

00:48:07.940 --> 00:48:11.839
quite easy because I have them in array and
I can run to those arrays.

00:48:11.839 --> 00:48:23.279
Now, to run through a array using a index
you need to have a concept of loop and that

00:48:23.279 --> 00:48:28.400
brings us to the shells scripts in a text
mode, so we will learn that in the upcoming

00:48:28.400 --> 00:48:35.299
classes where we will be able to write a set
of commands including the looping and conditional

00:48:35.299 --> 00:48:40.640
statements etcetera, so we will explore that
as we go along but these basic ideas about

00:48:40.640 --> 00:48:47.839
the variables and their values will be quite
use for us to imagine how we can accomplish

00:48:47.839 --> 00:48:48.759
the task at hand.

